/* soapC.cpp
   Generated by the gSOAP Stub and Skeleton Compiler for C and C++ 2.1.3b
   Copyright (C) 2001-2002 Robert A. van Engelen, Florida State University.
   All rights reserved.
*/
#include "soapH.h"

SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	return (soap->header = soap_get_SOAP_ENV__Header(soap, NULL, "SOAP-ENV:Header", NULL)) == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap->fault);
	}
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	return (const char**)&soap->fault->detail;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap) || !*soap->id)
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_xsd__int:
			soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			break;
		case SOAP_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_xsd__double:
			soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
			break;
		case SOAP_double:
			soap_in_double(soap, NULL, NULL, "");
			break;
		case SOAP_xsd__boolean:
			soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
			break;
		case SOAP_bool:
			soap_in_bool(soap, NULL, NULL, "boolean");
			break;
		case SOAP_mindcall__constructResourceDescriptionResponse:
			soap_in_mindcall__constructResourceDescriptionResponse(soap, NULL, NULL, "mindcall:constructResourceDescriptionResponse");
			break;
		case SOAP_mindcall__addDocumentResponse:
			soap_in_mindcall__addDocumentResponse(soap, NULL, NULL, "mindcall:addDocumentResponse");
			break;
		case SOAP_mindcall__clearDocumentsResponse:
			soap_in_mindcall__clearDocumentsResponse(soap, NULL, NULL, "mindcall:clearDocumentsResponse");
			break;
		case SOAP_mindcall__setCollectionNumDocsResponse:
			soap_in_mindcall__setCollectionNumDocsResponse(soap, NULL, NULL, "mindcall:setCollectionNumDocsResponse");
			break;
		case SOAP_mindcall__getSchemaResponse:
			soap_in_mindcall__getSchemaResponse(soap, NULL, NULL, "mindcall:getSchemaResponse");
			break;
		case SOAP_mindcall__extractQBSFeaturesResponse:
			soap_in_mindcall__extractQBSFeaturesResponse(soap, NULL, NULL, "mindcall:extractQBSFeaturesResponse");
			break;
		case SOAP_mindtype__FeatureList:
			soap_in_mindtype__FeatureList(soap, NULL, NULL, "mindtype:FeatureList");
			break;
		case SOAP_mindcall__queryResponse:
			soap_in_mindcall__queryResponse(soap, NULL, NULL, "mindcall:queryResponse");
			break;
		case SOAP_mindtype__PropResult:
			soap_in_mindtype__PropResult(soap, NULL, NULL, "mindtype:PropResult");
			break;
		case SOAP_mindtype__PropDocumentArray:
			soap_in_mindtype__PropDocumentArray(soap, NULL, NULL, "mindtype:PropDocumentArray");
			break;
		case SOAP_mindtype__PropDocument:
			soap_in_mindtype__PropDocument(soap, NULL, NULL, "mindtype:PropDocument");
			break;
		case SOAP_mindtype__PropDocumentAttributeArray:
			soap_in_mindtype__PropDocumentAttributeArray(soap, NULL, NULL, "mindtype:PropDocumentAttributeArray");
			break;
		case SOAP_mindtype__PropDocumentAttribute:
			soap_in_mindtype__PropDocumentAttribute(soap, NULL, NULL, "mindtype:PropDocumentAttribute");
			break;
		case SOAP_mindtype__DocumentID:
			soap_in_mindtype__DocumentID(soap, NULL, NULL, "mindtype:DocumentID");
			break;
		case SOAP_mindtype__SchemaArray:
			soap_in_mindtype__SchemaArray(soap, NULL, NULL, "mindtype:SchemaArray");
			break;
		case SOAP_mindtype__PropQuery:
			soap_in_mindtype__PropQuery(soap, NULL, NULL, "mindtype:PropQuery");
			break;
		case SOAP_PropQueryConditionArray:
			soap_in_PropQueryConditionArray(soap, NULL, NULL, "");
			break;
		case SOAP_mindtype__PropQueryCondition:
			soap_in_mindtype__PropQueryCondition(soap, NULL, NULL, "mindtype:PropQueryCondition");
			break;
		case SOAP_mindtype__Content:
			soap_in_mindtype__Content(soap, NULL, NULL, "mindtype:Content");
			break;
		case SOAP_mindtype__CostParameters:
			soap_in_mindtype__CostParameters(soap, NULL, NULL, "mindtype:CostParameters");
			break;
		case SOAP_mindtype__Query:
			soap_in_mindtype__Query(soap, NULL, NULL, "mindtype:Query");
			break;
		case SOAP_mindtype__Schema:
			soap_in_mindtype__Schema(soap, NULL, NULL, "mindtype:Schema");
			break;
		case SOAP_SchemaAttributeArray:
			soap_in_SchemaAttributeArray(soap, NULL, NULL, "");
			break;
		case SOAP_mindtype__SchemaAttribute:
			soap_in_mindtype__SchemaAttribute(soap, NULL, NULL, "mindtype:SchemaAttribute");
			break;
		case SOAP_PredicateArray:
			soap_in_PredicateArray(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Fault:
			soap_in_SOAP_ENV__Fault(soap, NULL, NULL, "");
			break;
		case SOAP_SOAP_ENV__Header:
			soap_in_SOAP_ENV__Header(soap, NULL, NULL, "");
			break;
		case SOAP_mindcall__constructResourceDescription:
			soap_in_mindcall__constructResourceDescription(soap, NULL, NULL, "mindcall:constructResourceDescription");
			break;
		case SOAP_mindcall__addDocument:
			soap_in_mindcall__addDocument(soap, NULL, NULL, "mindcall:addDocument");
			break;
		case SOAP_mindcall__clearDocuments:
			soap_in_mindcall__clearDocuments(soap, NULL, NULL, "mindcall:clearDocuments");
			break;
		case SOAP_mindcall__setCollectionNumDocs:
			soap_in_mindcall__setCollectionNumDocs(soap, NULL, NULL, "mindcall:setCollectionNumDocs");
			break;
		case SOAP_mindcall__getSchema:
			soap_in_mindcall__getSchema(soap, NULL, NULL, "mindcall:getSchema");
			break;
		case SOAP_mindcall__extractQBSFeatures:
			soap_in_mindcall__extractQBSFeatures(soap, NULL, NULL, "mindcall:extractQBSFeatures");
			break;
		case SOAP_mindcall__query:
			soap_in_mindcall__query(soap, NULL, NULL, "mindcall:query");
			break;
		case SOAP_mindcall__retrieveURL:
			soap_in_mindcall__retrieveURL(soap, NULL, NULL, "mindcall:retrieveURL");
			break;
		case SOAP_mindcall__retrieveURLResponse:
			soap_in_mindcall__retrieveURLResponse(soap, NULL, NULL, "mindcall:retrieveURLResponse");
			break;
		case SOAP_mindcall__getInternalStatus:
			soap_in_mindcall__getInternalStatus(soap, NULL, NULL, "mindcall:getInternalStatus");
			break;
		case SOAP_mindcall__getInternalStatusResponse:
			soap_in_mindcall__getInternalStatusResponse(soap, NULL, NULL, "mindcall:getInternalStatusResponse");
			break;
		case SOAP_PointerTomindcall__constructResourceDescriptionResponse:
			soap_in_PointerTomindcall__constructResourceDescriptionResponse(soap, NULL, NULL, "mindcall:constructResourceDescriptionResponse");
			break;
		case SOAP_PointerTomindcall__addDocumentResponse:
			soap_in_PointerTomindcall__addDocumentResponse(soap, NULL, NULL, "mindcall:addDocumentResponse");
			break;
		case SOAP_PointerTomindcall__clearDocumentsResponse:
			soap_in_PointerTomindcall__clearDocumentsResponse(soap, NULL, NULL, "mindcall:clearDocumentsResponse");
			break;
		case SOAP_PointerTomindcall__setCollectionNumDocsResponse:
			soap_in_PointerTomindcall__setCollectionNumDocsResponse(soap, NULL, NULL, "mindcall:setCollectionNumDocsResponse");
			break;
		case SOAP_PointerTomindcall__getSchemaResponse:
			soap_in_PointerTomindcall__getSchemaResponse(soap, NULL, NULL, "mindcall:getSchemaResponse");
			break;
		case SOAP_PointerTomindcall__extractQBSFeaturesResponse:
			soap_in_PointerTomindcall__extractQBSFeaturesResponse(soap, NULL, NULL, "mindcall:extractQBSFeaturesResponse");
			break;
		case SOAP_PointerTomindtype__FeatureList:
			soap_in_PointerTomindtype__FeatureList(soap, NULL, NULL, "mindtype:FeatureList");
			break;
		case SOAP_PointerTomindcall__queryResponse:
			soap_in_PointerTomindcall__queryResponse(soap, NULL, NULL, "mindcall:queryResponse");
			break;
		case SOAP_PointerTomindtype__PropResult:
			soap_in_PointerTomindtype__PropResult(soap, NULL, NULL, "mindtype:PropResult");
			break;
		case SOAP_PointerTomindtype__PropDocument:
			soap_in_PointerTomindtype__PropDocument(soap, NULL, NULL, "mindtype:PropDocument");
			break;
		case SOAP_PointerTomindtype__PropDocumentAttribute:
			soap_in_PointerTomindtype__PropDocumentAttribute(soap, NULL, NULL, "mindtype:PropDocumentAttribute");
			break;
		case SOAP_PointerTomindtype__Query:
			soap_in_PointerTomindtype__Query(soap, NULL, NULL, "mindtype:Query");
			break;
		case SOAP_PointerTomindtype__Schema:
			soap_in_PointerTomindtype__Schema(soap, NULL, NULL, "mindtype:Schema");
			break;
		case SOAP_PointerTomindtype__PropQueryCondition:
			soap_in_PointerTomindtype__PropQueryCondition(soap, NULL, NULL, "mindtype:PropQueryCondition");
			break;
		case SOAP_PointerToSchemaAttributeArray:
			soap_in_PointerToSchemaAttributeArray(soap, NULL, NULL, "");
			break;
		case SOAP_PointerToPointerTomindtype__SchemaAttribute:
			soap_in_PointerToPointerTomindtype__SchemaAttribute(soap, NULL, NULL, "mindtype:SchemaAttribute");
			break;
		case SOAP_PointerTomindtype__SchemaAttribute:
			soap_in_PointerTomindtype__SchemaAttribute(soap, NULL, NULL, "mindtype:SchemaAttribute");
			break;
		case SOAP_PointerToxsd__string:
			soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_xsd__string:
			soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__double(soap, NULL, NULL, "xsd:double");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_bool(soap, NULL, NULL, "boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__constructResourceDescriptionResponse(soap, NULL, NULL, "mindcall:constructResourceDescriptionResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__addDocumentResponse(soap, NULL, NULL, "mindcall:addDocumentResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__clearDocumentsResponse(soap, NULL, NULL, "mindcall:clearDocumentsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__setCollectionNumDocsResponse(soap, NULL, NULL, "mindcall:setCollectionNumDocsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__getSchemaResponse(soap, NULL, NULL, "mindcall:getSchemaResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__extractQBSFeaturesResponse(soap, NULL, NULL, "mindcall:extractQBSFeaturesResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__FeatureList(soap, NULL, NULL, "mindtype:FeatureList");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__queryResponse(soap, NULL, NULL, "mindcall:queryResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropResult(soap, NULL, NULL, "mindtype:PropResult");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropDocumentArray(soap, NULL, NULL, "mindtype:PropDocumentArray");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropDocument(soap, NULL, NULL, "mindtype:PropDocument");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropDocumentAttributeArray(soap, NULL, NULL, "mindtype:PropDocumentAttributeArray");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropDocumentAttribute(soap, NULL, NULL, "mindtype:PropDocumentAttribute");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__DocumentID(soap, NULL, NULL, "mindtype:DocumentID");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__SchemaArray(soap, NULL, NULL, "mindtype:SchemaArray");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropQuery(soap, NULL, NULL, "mindtype:PropQuery");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__PropQueryCondition(soap, NULL, NULL, "mindtype:PropQueryCondition");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__Content(soap, NULL, NULL, "mindtype:Content");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__CostParameters(soap, NULL, NULL, "mindtype:CostParameters");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__Query(soap, NULL, NULL, "mindtype:Query");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__Schema(soap, NULL, NULL, "mindtype:Schema");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindtype__SchemaAttribute(soap, NULL, NULL, "mindtype:SchemaAttribute");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__constructResourceDescription(soap, NULL, NULL, "mindcall:constructResourceDescription");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__addDocument(soap, NULL, NULL, "mindcall:addDocument");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__clearDocuments(soap, NULL, NULL, "mindcall:clearDocuments");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__setCollectionNumDocs(soap, NULL, NULL, "mindcall:setCollectionNumDocs");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__getSchema(soap, NULL, NULL, "mindcall:getSchema");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__extractQBSFeatures(soap, NULL, NULL, "mindcall:extractQBSFeatures");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__query(soap, NULL, NULL, "mindcall:query");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__retrieveURL(soap, NULL, NULL, "mindcall:retrieveURL");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__retrieveURLResponse(soap, NULL, NULL, "mindcall:retrieveURLResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__getInternalStatus(soap, NULL, NULL, "mindcall:getInternalStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_mindcall__getInternalStatusResponse(soap, NULL, NULL, "mindcall:getInternalStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			if (soap->error)
				soap_ignore_element(soap);
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->enable_embedding || soap->disable_href)
		return;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (soap->counting ? pp->mark1 == 2 : pp ->mark2 == 2)
				switch (pp->type & 0xFF)
				{
				case SOAP_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "");
					break;
				case SOAP_xsd__int:
					soap_out_xsd__int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "");
					break;
				case SOAP_xsd__double:
					soap_out_xsd__double(soap, "id", pp->id, (const double *)pp->ptr, "xsd:double");
					break;
				case SOAP_double:
					soap_out_double(soap, "id", pp->id, (const double *)pp->ptr, "");
					break;
				case SOAP_xsd__boolean:
					soap_out_xsd__boolean(soap, "id", pp->id, (const bool *)pp->ptr, "xsd:boolean");
					break;
				case SOAP_bool:
					soap_out_bool(soap, "id", pp->id, (const bool *)pp->ptr, "boolean");
					break;
				case SOAP_mindcall__constructResourceDescriptionResponse:
					((mindcall__constructResourceDescriptionResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:constructResourceDescriptionResponse");
					break;
				case SOAP_mindcall__addDocumentResponse:
					((mindcall__addDocumentResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:addDocumentResponse");
					break;
				case SOAP_mindcall__clearDocumentsResponse:
					((mindcall__clearDocumentsResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:clearDocumentsResponse");
					break;
				case SOAP_mindcall__setCollectionNumDocsResponse:
					((mindcall__setCollectionNumDocsResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:setCollectionNumDocsResponse");
					break;
				case SOAP_mindcall__getSchemaResponse:
					((mindcall__getSchemaResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:getSchemaResponse");
					break;
				case SOAP_mindcall__extractQBSFeaturesResponse:
					((mindcall__extractQBSFeaturesResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:extractQBSFeaturesResponse");
					break;
				case SOAP_mindtype__FeatureList:
					((mindtype__FeatureList *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:FeatureList");
					break;
				case SOAP_mindcall__queryResponse:
					((mindcall__queryResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "mindcall:queryResponse");
					break;
				case SOAP_mindtype__PropResult:
					((mindtype__PropResult *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropResult");
					break;
				case SOAP_mindtype__PropDocumentArray:
					((mindtype__PropDocumentArray *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropDocumentArray");
					break;
				case SOAP_mindtype__PropDocument:
					((mindtype__PropDocument *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropDocument");
					break;
				case SOAP_mindtype__PropDocumentAttributeArray:
					((mindtype__PropDocumentAttributeArray *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropDocumentAttributeArray");
					break;
				case SOAP_mindtype__PropDocumentAttribute:
					((mindtype__PropDocumentAttribute *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropDocumentAttribute");
					break;
				case SOAP_mindtype__DocumentID:
					((mindtype__DocumentID *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:DocumentID");
					break;
				case SOAP_mindtype__SchemaArray:
					((mindtype__SchemaArray *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:SchemaArray");
					break;
				case SOAP_mindtype__PropQuery:
					((mindtype__PropQuery *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropQuery");
					break;
				case SOAP_PropQueryConditionArray:
					((PropQueryConditionArray *)pp->ptr)->soap_out(soap, "id", pp->id, "");
					break;
				case SOAP_mindtype__PropQueryCondition:
					((mindtype__PropQueryCondition *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:PropQueryCondition");
					break;
				case SOAP_mindtype__Content:
					((mindtype__Content *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:Content");
					break;
				case SOAP_mindtype__CostParameters:
					((mindtype__CostParameters *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:CostParameters");
					break;
				case SOAP_mindtype__Query:
					((mindtype__Query *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:Query");
					break;
				case SOAP_mindtype__Schema:
					((mindtype__Schema *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:Schema");
					break;
				case SOAP_SchemaAttributeArray:
					((SchemaAttributeArray *)pp->ptr)->soap_out(soap, "id", pp->id, "");
					break;
				case SOAP_mindtype__SchemaAttribute:
					((mindtype__SchemaAttribute *)pp->ptr)->soap_out(soap, "id", pp->id, "mindtype:SchemaAttribute");
					break;
				case SOAP_PredicateArray:
					((PredicateArray *)pp->ptr)->soap_out(soap, "id", pp->id, "");
					break;
				case SOAP_SOAP_ENV__Fault:
					soap_out_SOAP_ENV__Fault(soap, "id", pp->id, (const struct SOAP_ENV__Fault *)pp->ptr, "");
					break;
				case SOAP_SOAP_ENV__Header:
					soap_out_SOAP_ENV__Header(soap, "id", pp->id, (const struct SOAP_ENV__Header *)pp->ptr, "");
					break;
				case SOAP_mindcall__constructResourceDescription:
					soap_out_mindcall__constructResourceDescription(soap, "id", pp->id, (const struct mindcall__constructResourceDescription *)pp->ptr, "mindcall:constructResourceDescription");
					break;
				case SOAP_mindcall__addDocument:
					soap_out_mindcall__addDocument(soap, "id", pp->id, (const struct mindcall__addDocument *)pp->ptr, "mindcall:addDocument");
					break;
				case SOAP_mindcall__clearDocuments:
					soap_out_mindcall__clearDocuments(soap, "id", pp->id, (const struct mindcall__clearDocuments *)pp->ptr, "mindcall:clearDocuments");
					break;
				case SOAP_mindcall__setCollectionNumDocs:
					soap_out_mindcall__setCollectionNumDocs(soap, "id", pp->id, (const struct mindcall__setCollectionNumDocs *)pp->ptr, "mindcall:setCollectionNumDocs");
					break;
				case SOAP_mindcall__getSchema:
					soap_out_mindcall__getSchema(soap, "id", pp->id, (const struct mindcall__getSchema *)pp->ptr, "mindcall:getSchema");
					break;
				case SOAP_mindcall__extractQBSFeatures:
					soap_out_mindcall__extractQBSFeatures(soap, "id", pp->id, (const struct mindcall__extractQBSFeatures *)pp->ptr, "mindcall:extractQBSFeatures");
					break;
				case SOAP_mindcall__query:
					soap_out_mindcall__query(soap, "id", pp->id, (const struct mindcall__query *)pp->ptr, "mindcall:query");
					break;
				case SOAP_mindcall__retrieveURL:
					soap_out_mindcall__retrieveURL(soap, "id", pp->id, (const struct mindcall__retrieveURL *)pp->ptr, "mindcall:retrieveURL");
					break;
				case SOAP_mindcall__retrieveURLResponse:
					soap_out_mindcall__retrieveURLResponse(soap, "id", pp->id, (const struct mindcall__retrieveURLResponse *)pp->ptr, "mindcall:retrieveURLResponse");
					break;
				case SOAP_mindcall__getInternalStatus:
					soap_out_mindcall__getInternalStatus(soap, "id", pp->id, (const struct mindcall__getInternalStatus *)pp->ptr, "mindcall:getInternalStatus");
					break;
				case SOAP_mindcall__getInternalStatusResponse:
					soap_out_mindcall__getInternalStatusResponse(soap, "id", pp->id, (const struct mindcall__getInternalStatusResponse *)pp->ptr, "mindcall:getInternalStatusResponse");
					break;
				case SOAP_xsd__string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				case SOAP_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "");
					break;
				}
		
	
}

SOAP_FMAC1 void SOAP_FMAC2 *soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType)
{
	switch (t)
	{
	case SOAP_PredicateArray:
		return (void*)soap_instantiate_PredicateArray(soap, -1, type, arrayType);
	case SOAP_mindtype__SchemaAttribute:
		return (void*)soap_instantiate_mindtype__SchemaAttribute(soap, -1, type, arrayType);
	case SOAP_SchemaAttributeArray:
		return (void*)soap_instantiate_SchemaAttributeArray(soap, -1, type, arrayType);
	case SOAP_mindtype__Schema:
		return (void*)soap_instantiate_mindtype__Schema(soap, -1, type, arrayType);
	case SOAP_mindtype__Query:
		return (void*)soap_instantiate_mindtype__Query(soap, -1, type, arrayType);
	case SOAP_mindtype__CostParameters:
		return (void*)soap_instantiate_mindtype__CostParameters(soap, -1, type, arrayType);
	case SOAP_mindtype__Content:
		return (void*)soap_instantiate_mindtype__Content(soap, -1, type, arrayType);
	case SOAP_mindtype__PropQueryCondition:
		return (void*)soap_instantiate_mindtype__PropQueryCondition(soap, -1, type, arrayType);
	case SOAP_PropQueryConditionArray:
		return (void*)soap_instantiate_PropQueryConditionArray(soap, -1, type, arrayType);
	case SOAP_mindtype__PropQuery:
		return (void*)soap_instantiate_mindtype__PropQuery(soap, -1, type, arrayType);
	case SOAP_mindtype__SchemaArray:
		return (void*)soap_instantiate_mindtype__SchemaArray(soap, -1, type, arrayType);
	case SOAP_mindtype__DocumentID:
		return (void*)soap_instantiate_mindtype__DocumentID(soap, -1, type, arrayType);
	case SOAP_mindtype__PropDocumentAttribute:
		return (void*)soap_instantiate_mindtype__PropDocumentAttribute(soap, -1, type, arrayType);
	case SOAP_mindtype__PropDocumentAttributeArray:
		return (void*)soap_instantiate_mindtype__PropDocumentAttributeArray(soap, -1, type, arrayType);
	case SOAP_mindtype__PropDocument:
		return (void*)soap_instantiate_mindtype__PropDocument(soap, -1, type, arrayType);
	case SOAP_mindtype__PropDocumentArray:
		return (void*)soap_instantiate_mindtype__PropDocumentArray(soap, -1, type, arrayType);
	case SOAP_mindtype__PropResult:
		return (void*)soap_instantiate_mindtype__PropResult(soap, -1, type, arrayType);
	case SOAP_mindcall__queryResponse:
		return (void*)soap_instantiate_mindcall__queryResponse(soap, -1, type, arrayType);
	case SOAP_mindtype__FeatureList:
		return (void*)soap_instantiate_mindtype__FeatureList(soap, -1, type, arrayType);
	case SOAP_mindcall__extractQBSFeaturesResponse:
		return (void*)soap_instantiate_mindcall__extractQBSFeaturesResponse(soap, -1, type, arrayType);
	case SOAP_mindcall__getSchemaResponse:
		return (void*)soap_instantiate_mindcall__getSchemaResponse(soap, -1, type, arrayType);
	case SOAP_mindcall__setCollectionNumDocsResponse:
		return (void*)soap_instantiate_mindcall__setCollectionNumDocsResponse(soap, -1, type, arrayType);
	case SOAP_mindcall__clearDocumentsResponse:
		return (void*)soap_instantiate_mindcall__clearDocumentsResponse(soap, -1, type, arrayType);
	case SOAP_mindcall__addDocumentResponse:
		return (void*)soap_instantiate_mindcall__addDocumentResponse(soap, -1, type, arrayType);
	case SOAP_mindcall__constructResourceDescriptionResponse:
		return (void*)soap_instantiate_mindcall__constructResourceDescriptionResponse(soap, -1, type, arrayType);
	}
	return NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_delete(struct soap *soap, void *p, int t, int n)
{
	switch (t)
	{
	case SOAP_PredicateArray:
		if (n<0)
			delete (PredicateArray*)p;
		else
			delete[] (PredicateArray*)p;
		break;
	case SOAP_mindtype__SchemaAttribute:
		if (n<0)
			delete (mindtype__SchemaAttribute*)p;
		else
			delete[] (mindtype__SchemaAttribute*)p;
		break;
	case SOAP_SchemaAttributeArray:
		if (n<0)
			delete (SchemaAttributeArray*)p;
		else
			delete[] (SchemaAttributeArray*)p;
		break;
	case SOAP_mindtype__Schema:
		if (n<0)
			delete (mindtype__Schema*)p;
		else
			delete[] (mindtype__Schema*)p;
		break;
	case SOAP_mindtype__Query:
		if (n<0)
			delete (mindtype__Query*)p;
		else
			delete[] (mindtype__Query*)p;
		break;
	case SOAP_mindtype__CostParameters:
		if (n<0)
			delete (mindtype__CostParameters*)p;
		else
			delete[] (mindtype__CostParameters*)p;
		break;
	case SOAP_mindtype__Content:
		if (n<0)
			delete (mindtype__Content*)p;
		else
			delete[] (mindtype__Content*)p;
		break;
	case SOAP_mindtype__PropQueryCondition:
		if (n<0)
			delete (mindtype__PropQueryCondition*)p;
		else
			delete[] (mindtype__PropQueryCondition*)p;
		break;
	case SOAP_PropQueryConditionArray:
		if (n<0)
			delete (PropQueryConditionArray*)p;
		else
			delete[] (PropQueryConditionArray*)p;
		break;
	case SOAP_mindtype__PropQuery:
		if (n<0)
			delete (mindtype__PropQuery*)p;
		else
			delete[] (mindtype__PropQuery*)p;
		break;
	case SOAP_mindtype__SchemaArray:
		if (n<0)
			delete (mindtype__SchemaArray*)p;
		else
			delete[] (mindtype__SchemaArray*)p;
		break;
	case SOAP_mindtype__DocumentID:
		if (n<0)
			delete (mindtype__DocumentID*)p;
		else
			delete[] (mindtype__DocumentID*)p;
		break;
	case SOAP_mindtype__PropDocumentAttribute:
		if (n<0)
			delete (mindtype__PropDocumentAttribute*)p;
		else
			delete[] (mindtype__PropDocumentAttribute*)p;
		break;
	case SOAP_mindtype__PropDocumentAttributeArray:
		if (n<0)
			delete (mindtype__PropDocumentAttributeArray*)p;
		else
			delete[] (mindtype__PropDocumentAttributeArray*)p;
		break;
	case SOAP_mindtype__PropDocument:
		if (n<0)
			delete (mindtype__PropDocument*)p;
		else
			delete[] (mindtype__PropDocument*)p;
		break;
	case SOAP_mindtype__PropDocumentArray:
		if (n<0)
			delete (mindtype__PropDocumentArray*)p;
		else
			delete[] (mindtype__PropDocumentArray*)p;
		break;
	case SOAP_mindtype__PropResult:
		if (n<0)
			delete (mindtype__PropResult*)p;
		else
			delete[] (mindtype__PropResult*)p;
		break;
	case SOAP_mindcall__queryResponse:
		if (n<0)
			delete (mindcall__queryResponse*)p;
		else
			delete[] (mindcall__queryResponse*)p;
		break;
	case SOAP_mindtype__FeatureList:
		if (n<0)
			delete (mindtype__FeatureList*)p;
		else
			delete[] (mindtype__FeatureList*)p;
		break;
	case SOAP_mindcall__extractQBSFeaturesResponse:
		if (n<0)
			delete (mindcall__extractQBSFeaturesResponse*)p;
		else
			delete[] (mindcall__extractQBSFeaturesResponse*)p;
		break;
	case SOAP_mindcall__getSchemaResponse:
		if (n<0)
			delete (mindcall__getSchemaResponse*)p;
		else
			delete[] (mindcall__getSchemaResponse*)p;
		break;
	case SOAP_mindcall__setCollectionNumDocsResponse:
		if (n<0)
			delete (mindcall__setCollectionNumDocsResponse*)p;
		else
			delete[] (mindcall__setCollectionNumDocsResponse*)p;
		break;
	case SOAP_mindcall__clearDocumentsResponse:
		if (n<0)
			delete (mindcall__clearDocumentsResponse*)p;
		else
			delete[] (mindcall__clearDocumentsResponse*)p;
		break;
	case SOAP_mindcall__addDocumentResponse:
		if (n<0)
			delete (mindcall__addDocumentResponse*)p;
		else
			delete[] (mindcall__addDocumentResponse*)p;
		break;
	case SOAP_mindcall__constructResourceDescriptionResponse:
		if (n<0)
			delete (mindcall__constructResourceDescriptionResponse*)p;
		else
			delete[] (mindcall__constructResourceDescriptionResponse*)p;
		break;
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	soap_outbyte(soap, tag, id, a, type, SOAP_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__int(int *a)
{
#ifdef SOAP_DEFAULT_xsd__int
	*a = SOAP_DEFAULT_xsd__int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_xsd__int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_xsd__int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__int(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__int(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	soap_outint(soap, tag, id, a, type, SOAP_xsd__int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	soap_outint(soap, tag, id, a, type, SOAP_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__double(struct soap *soap, double const*a)
{
	soap_reference(soap, a, SOAP_xsd__double);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__double(double *a)
{
#ifdef SOAP_DEFAULT_xsd__double
	*a = SOAP_DEFAULT_xsd__double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_xsd__double(struct soap *soap, double *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_xsd__double, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__double(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__double(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__double(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_xsd__double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	soap_outdouble(soap, tag, id, a, type, SOAP_xsd__double);
}

SOAP_FMAC1 double * SOAP_FMAC2 soap_get_xsd__double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 double * SOAP_FMAC2 soap_in_xsd__double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_xsd__double);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_double(struct soap *soap, double const*a)
{
	soap_reference(soap, a, SOAP_double);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_double(double *a)
{
#ifdef SOAP_DEFAULT_double
	*a = SOAP_DEFAULT_double;
#else
	*a = (double)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_double(struct soap *soap, double *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_double, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_double(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_double(soap, tag, i, a, type);
		}
	else
		soap_out_double(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_double(struct soap *soap, const char *tag, int id, const double *a, const char *type)
{
	soap_outdouble(soap, tag, id, a, type, SOAP_double);
}

SOAP_FMAC1 double * SOAP_FMAC2 soap_get_double(struct soap *soap, double *p, const char *tag, const char *type)
{
	if ((p = soap_in_double(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 double * SOAP_FMAC2 soap_in_double(struct soap *soap, const char *tag, double *a, const char *type)
{
	return soap_indouble(soap, tag, a, type, SOAP_double);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__boolean(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_xsd__boolean);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__boolean(bool *a)
{
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_xsd__boolean(struct soap *soap, bool *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_xsd__boolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__boolean(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__boolean(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__boolean(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_xsd__boolean), type);
	switch (*a)
	{
		case false: soap_send(soap, "false"); break;
		case true: soap_send(soap, "true"); break;
		default:
			sprintf(soap->tagbuf, "%lld", (LONG64)*a);
			soap_send(soap, soap->tagbuf);
			break;
	}
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{	char *s;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
	soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_xsd__boolean, sizeof(bool), 0);
		if (!a)
			return NULL;
		s = soap_value(soap);
		if (!strcmp(s, "false"))
			*a = false;
		else if (!strcmp(s, "true"))
			*a = true;
		else 
		{	*a = (bool)strtol(s, &s, 10);
			if (*s)
			{	soap->error = SOAP_TYPE_MISMATCH;
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_xsd__boolean, sizeof(bool), 0), SOAP_xsd__boolean, sizeof(bool));
		if (soap->alloced)
			soap_default_xsd__boolean(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_bool(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_bool);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_bool(bool *a)
{
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_bool(struct soap *soap, bool *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_bool, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_bool(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_bool(soap, tag, i, a, type);
		}
	else
		soap_out_bool(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_bool), type);
	switch (*a)
	{
		case false: soap_send(soap, "false"); break;
		case true: soap_send(soap, "true"); break;
		default:
			sprintf(soap->tagbuf, "%lld", (LONG64)*a);
			soap_send(soap, soap->tagbuf);
			break;
	}
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{	char *s;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
	soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_bool, sizeof(bool), 0);
		if (!a)
			return NULL;
		s = soap_value(soap);
		if (!strcmp(s, "false"))
			*a = false;
		else if (!strcmp(s, "true"))
			*a = true;
		else 
		{	*a = (bool)strtol(s, &s, 10);
			if (*s)
			{	soap->error = SOAP_TYPE_MISMATCH;
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_bool, sizeof(bool), 0), SOAP_bool, sizeof(bool));
		if (soap->alloced)
			soap_default_bool(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void mindcall__constructResourceDescriptionResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__constructResourceDescriptionResponse))
		this->soap_mark(soap);
}

void mindcall__constructResourceDescriptionResponse::soap_mark(struct soap *soap) const
{
}

void mindcall__constructResourceDescriptionResponse::soap_default()
{
}

void mindcall__constructResourceDescriptionResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__constructResourceDescriptionResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__constructResourceDescriptionResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__constructResourceDescriptionResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__constructResourceDescriptionResponse(struct soap *soap, const char *tag, int id, const mindcall__constructResourceDescriptionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__constructResourceDescriptionResponse), "mindcall:constructResourceDescriptionResponse");
	soap_element_end_out(soap, tag);
}

void *mindcall__constructResourceDescriptionResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__constructResourceDescriptionResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__constructResourceDescriptionResponse * SOAP_FMAC2 soap_get_mindcall__constructResourceDescriptionResponse(struct soap *soap, mindcall__constructResourceDescriptionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__constructResourceDescriptionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__constructResourceDescriptionResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__constructResourceDescriptionResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__constructResourceDescriptionResponse * SOAP_FMAC2 soap_in_mindcall__constructResourceDescriptionResponse(struct soap *soap, const char *tag, mindcall__constructResourceDescriptionResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__constructResourceDescriptionResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__constructResourceDescriptionResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__constructResourceDescriptionResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__constructResourceDescriptionResponse *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__constructResourceDescriptionResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__constructResourceDescriptionResponse, soap->type, soap->arrayType), SOAP_mindcall__constructResourceDescriptionResponse, sizeof(mindcall__constructResourceDescriptionResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__constructResourceDescriptionResponse * SOAP_FMAC2 soap_instantiate_mindcall__constructResourceDescriptionResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__constructResourceDescriptionResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__constructResourceDescriptionResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__constructResourceDescriptionResponse*)(cp->ptr = new mindcall__constructResourceDescriptionResponse);
	else
		return (mindcall__constructResourceDescriptionResponse*)(cp->ptr = new mindcall__constructResourceDescriptionResponse[n]);
}

void mindcall__addDocumentResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__addDocumentResponse))
		this->soap_mark(soap);
}

void mindcall__addDocumentResponse::soap_mark(struct soap *soap) const
{
}

void mindcall__addDocumentResponse::soap_default()
{
}

void mindcall__addDocumentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__addDocumentResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__addDocumentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__addDocumentResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__addDocumentResponse(struct soap *soap, const char *tag, int id, const mindcall__addDocumentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__addDocumentResponse), "mindcall:addDocumentResponse");
	soap_element_end_out(soap, tag);
}

void *mindcall__addDocumentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__addDocumentResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__addDocumentResponse * SOAP_FMAC2 soap_get_mindcall__addDocumentResponse(struct soap *soap, mindcall__addDocumentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__addDocumentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__addDocumentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__addDocumentResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__addDocumentResponse * SOAP_FMAC2 soap_in_mindcall__addDocumentResponse(struct soap *soap, const char *tag, mindcall__addDocumentResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__addDocumentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__addDocumentResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__addDocumentResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__addDocumentResponse *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__addDocumentResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__addDocumentResponse, soap->type, soap->arrayType), SOAP_mindcall__addDocumentResponse, sizeof(mindcall__addDocumentResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__addDocumentResponse * SOAP_FMAC2 soap_instantiate_mindcall__addDocumentResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__addDocumentResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__addDocumentResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__addDocumentResponse*)(cp->ptr = new mindcall__addDocumentResponse);
	else
		return (mindcall__addDocumentResponse*)(cp->ptr = new mindcall__addDocumentResponse[n]);
}

void mindcall__clearDocumentsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__clearDocumentsResponse))
		this->soap_mark(soap);
}

void mindcall__clearDocumentsResponse::soap_mark(struct soap *soap) const
{
}

void mindcall__clearDocumentsResponse::soap_default()
{
}

void mindcall__clearDocumentsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__clearDocumentsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__clearDocumentsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__clearDocumentsResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__clearDocumentsResponse(struct soap *soap, const char *tag, int id, const mindcall__clearDocumentsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__clearDocumentsResponse), "mindcall:clearDocumentsResponse");
	soap_element_end_out(soap, tag);
}

void *mindcall__clearDocumentsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__clearDocumentsResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__clearDocumentsResponse * SOAP_FMAC2 soap_get_mindcall__clearDocumentsResponse(struct soap *soap, mindcall__clearDocumentsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__clearDocumentsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__clearDocumentsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__clearDocumentsResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__clearDocumentsResponse * SOAP_FMAC2 soap_in_mindcall__clearDocumentsResponse(struct soap *soap, const char *tag, mindcall__clearDocumentsResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__clearDocumentsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__clearDocumentsResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__clearDocumentsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__clearDocumentsResponse *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__clearDocumentsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__clearDocumentsResponse, soap->type, soap->arrayType), SOAP_mindcall__clearDocumentsResponse, sizeof(mindcall__clearDocumentsResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__clearDocumentsResponse * SOAP_FMAC2 soap_instantiate_mindcall__clearDocumentsResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__clearDocumentsResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__clearDocumentsResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__clearDocumentsResponse*)(cp->ptr = new mindcall__clearDocumentsResponse);
	else
		return (mindcall__clearDocumentsResponse*)(cp->ptr = new mindcall__clearDocumentsResponse[n]);
}

void mindcall__setCollectionNumDocsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__setCollectionNumDocsResponse))
		this->soap_mark(soap);
}

void mindcall__setCollectionNumDocsResponse::soap_mark(struct soap *soap) const
{
}

void mindcall__setCollectionNumDocsResponse::soap_default()
{
}

void mindcall__setCollectionNumDocsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__setCollectionNumDocsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__setCollectionNumDocsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__setCollectionNumDocsResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__setCollectionNumDocsResponse(struct soap *soap, const char *tag, int id, const mindcall__setCollectionNumDocsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__setCollectionNumDocsResponse), "mindcall:setCollectionNumDocsResponse");
	soap_element_end_out(soap, tag);
}

void *mindcall__setCollectionNumDocsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__setCollectionNumDocsResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__setCollectionNumDocsResponse * SOAP_FMAC2 soap_get_mindcall__setCollectionNumDocsResponse(struct soap *soap, mindcall__setCollectionNumDocsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__setCollectionNumDocsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__setCollectionNumDocsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__setCollectionNumDocsResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__setCollectionNumDocsResponse * SOAP_FMAC2 soap_in_mindcall__setCollectionNumDocsResponse(struct soap *soap, const char *tag, mindcall__setCollectionNumDocsResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__setCollectionNumDocsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__setCollectionNumDocsResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__setCollectionNumDocsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__setCollectionNumDocsResponse *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__setCollectionNumDocsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__setCollectionNumDocsResponse, soap->type, soap->arrayType), SOAP_mindcall__setCollectionNumDocsResponse, sizeof(mindcall__setCollectionNumDocsResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__setCollectionNumDocsResponse * SOAP_FMAC2 soap_instantiate_mindcall__setCollectionNumDocsResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__setCollectionNumDocsResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__setCollectionNumDocsResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__setCollectionNumDocsResponse*)(cp->ptr = new mindcall__setCollectionNumDocsResponse);
	else
		return (mindcall__setCollectionNumDocsResponse*)(cp->ptr = new mindcall__setCollectionNumDocsResponse[n]);
}

void mindcall__getSchemaResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__getSchemaResponse))
		this->soap_mark(soap);
}

void mindcall__getSchemaResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindcall__getSchemaResponse*)this)->mindtype__return, SOAP_PointerTomindtype__Schema);
	soap_mark_PointerTomindtype__Schema(soap, &((mindcall__getSchemaResponse*)this)->mindtype__return);
}

void mindcall__getSchemaResponse::soap_default()
{
	soap_default_PointerTomindtype__Schema(&((mindcall__getSchemaResponse*)this)->mindtype__return);
}

void mindcall__getSchemaResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__getSchemaResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__getSchemaResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__getSchemaResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__getSchemaResponse(struct soap *soap, const char *tag, int id, const mindcall__getSchemaResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__getSchemaResponse), "mindcall:getSchemaResponse");
	soap_out_PointerTomindtype__Schema(soap, "mindtype:return", -1, &(((mindcall__getSchemaResponse*)a)->mindtype__return), "mindtype:Schema");
	soap_element_end_out(soap, tag);
}

void *mindcall__getSchemaResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__getSchemaResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__getSchemaResponse * SOAP_FMAC2 soap_get_mindcall__getSchemaResponse(struct soap *soap, mindcall__getSchemaResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__getSchemaResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__getSchemaResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__getSchemaResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__getSchemaResponse * SOAP_FMAC2 soap_in_mindcall__getSchemaResponse(struct soap *soap, const char *tag, mindcall__getSchemaResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__getSchemaResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__getSchemaResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__getSchemaResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__getSchemaResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_mindtype__return1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_mindtype__return1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__Schema(soap, "mindtype:return", &(((mindcall__getSchemaResponse*)a)->mindtype__return), "mindtype:Schema"))
				{	soap_flag_mindtype__return1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__getSchemaResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__getSchemaResponse, soap->type, soap->arrayType), SOAP_mindcall__getSchemaResponse, sizeof(mindcall__getSchemaResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__getSchemaResponse * SOAP_FMAC2 soap_instantiate_mindcall__getSchemaResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__getSchemaResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__getSchemaResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__getSchemaResponse*)(cp->ptr = new mindcall__getSchemaResponse);
	else
		return (mindcall__getSchemaResponse*)(cp->ptr = new mindcall__getSchemaResponse[n]);
}

void mindcall__extractQBSFeaturesResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__extractQBSFeaturesResponse))
		this->soap_mark(soap);
}

void mindcall__extractQBSFeaturesResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindcall__extractQBSFeaturesResponse*)this)->mindtype__return, SOAP_PointerTomindtype__FeatureList);
	soap_mark_PointerTomindtype__FeatureList(soap, &((mindcall__extractQBSFeaturesResponse*)this)->mindtype__return);
}

void mindcall__extractQBSFeaturesResponse::soap_default()
{
	soap_default_PointerTomindtype__FeatureList(&((mindcall__extractQBSFeaturesResponse*)this)->mindtype__return);
}

void mindcall__extractQBSFeaturesResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__extractQBSFeaturesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__extractQBSFeaturesResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__extractQBSFeaturesResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__extractQBSFeaturesResponse(struct soap *soap, const char *tag, int id, const mindcall__extractQBSFeaturesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__extractQBSFeaturesResponse), "mindcall:extractQBSFeaturesResponse");
	soap_out_PointerTomindtype__FeatureList(soap, "mindtype:return", -1, &(((mindcall__extractQBSFeaturesResponse*)a)->mindtype__return), "mindtype:FeatureList");
	soap_element_end_out(soap, tag);
}

void *mindcall__extractQBSFeaturesResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__extractQBSFeaturesResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__extractQBSFeaturesResponse * SOAP_FMAC2 soap_get_mindcall__extractQBSFeaturesResponse(struct soap *soap, mindcall__extractQBSFeaturesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__extractQBSFeaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__extractQBSFeaturesResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__extractQBSFeaturesResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__extractQBSFeaturesResponse * SOAP_FMAC2 soap_in_mindcall__extractQBSFeaturesResponse(struct soap *soap, const char *tag, mindcall__extractQBSFeaturesResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__extractQBSFeaturesResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__extractQBSFeaturesResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__extractQBSFeaturesResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__extractQBSFeaturesResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_mindtype__return1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_mindtype__return1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__FeatureList(soap, "mindtype:return", &(((mindcall__extractQBSFeaturesResponse*)a)->mindtype__return), "mindtype:FeatureList"))
				{	soap_flag_mindtype__return1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__extractQBSFeaturesResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__extractQBSFeaturesResponse, soap->type, soap->arrayType), SOAP_mindcall__extractQBSFeaturesResponse, sizeof(mindcall__extractQBSFeaturesResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__extractQBSFeaturesResponse * SOAP_FMAC2 soap_instantiate_mindcall__extractQBSFeaturesResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__extractQBSFeaturesResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__extractQBSFeaturesResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__extractQBSFeaturesResponse*)(cp->ptr = new mindcall__extractQBSFeaturesResponse);
	else
		return (mindcall__extractQBSFeaturesResponse*)(cp->ptr = new mindcall__extractQBSFeaturesResponse[n]);
}

void mindtype__FeatureList::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void mindtype__FeatureList::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, this->__size, SOAP_mindtype__FeatureList))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_xsd__string);
			soap_mark_xsd__string(soap, this->__ptr + i);
		}
}

void mindtype__FeatureList::soap_default()
{
	this->__size = 0;
	this->__ptr = NULL;
}

void mindtype__FeatureList::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, this->__size, SOAP_mindtype__FeatureList, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__FeatureList::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	soap_out_mindtype__FeatureList(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__FeatureList(struct soap *soap, const char *tag, int id, const mindtype__FeatureList *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	if (n != 0 && !a->__ptr)
	{	soap_element_null(soap, tag, id, type);
		return;
	}
	i = soap_array_pointer_lookup(soap, a, n, SOAP_mindtype__FeatureList, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return;
		}
		else if (soap_is_single(soap, pp))
			i = 0;
	}
	soap_element_begin_out(soap, tag, id, "mindtype:FeatureList");
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		soap_out_xsd__string(soap, "item", 0, &a->__ptr[i], "xsd:string");
	}
	soap_element_end_out(soap, tag);
}

void *mindtype__FeatureList::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__FeatureList(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__FeatureList * SOAP_FMAC2 soap_get_mindtype__FeatureList(struct soap *soap, mindtype__FeatureList *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__FeatureList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__FeatureList::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__FeatureList(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__FeatureList * SOAP_FMAC2 soap_in_mindtype__FeatureList(struct soap *soap, const char *tag, mindtype__FeatureList *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (mindtype__FeatureList *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__FeatureList, soap->type, soap->arrayType)))
			a->soap_default();
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__FeatureList *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__FeatureList, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default();
		a->__size = soap_getsize(soap->arraySize, soap->offset, &j);
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = (char **)malloc(sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_xsd__string(a->__ptr+i);
			for (i = j; i < j+a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr+i, "xsd:string"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{
				p = (char **)soap_push_block(soap, sizeof(char *));
				soap_default_xsd__string(p);
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
			soap_pop_block(soap);
			a->__ptr = (char **)malloc(soap->blist->size);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__FeatureList *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__FeatureList, soap->type, soap->arrayType), SOAP_mindtype__FeatureList, sizeof(mindtype__FeatureList));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__FeatureList * SOAP_FMAC2 soap_instantiate_mindtype__FeatureList(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__FeatureList(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__FeatureList;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__FeatureList*)(cp->ptr = new mindtype__FeatureList);
	else
		return (mindtype__FeatureList*)(cp->ptr = new mindtype__FeatureList[n]);
}

void mindcall__queryResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindcall__queryResponse))
		this->soap_mark(soap);
}

void mindcall__queryResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindcall__queryResponse*)this)->mindtype__return, SOAP_PointerTomindtype__PropResult);
	soap_mark_PointerTomindtype__PropResult(soap, &((mindcall__queryResponse*)this)->mindtype__return);
}

void mindcall__queryResponse::soap_default()
{
	soap_default_PointerTomindtype__PropResult(&((mindcall__queryResponse*)this)->mindtype__return);
}

void mindcall__queryResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindcall__queryResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindcall__queryResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindcall__queryResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__queryResponse(struct soap *soap, const char *tag, int id, const mindcall__queryResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__queryResponse), "mindcall:queryResponse");
	soap_out_PointerTomindtype__PropResult(soap, "mindtype:return", -1, &(((mindcall__queryResponse*)a)->mindtype__return), "mindtype:PropResult");
	soap_element_end_out(soap, tag);
}

void *mindcall__queryResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindcall__queryResponse(soap, this, tag, type);
}

SOAP_FMAC1 mindcall__queryResponse * SOAP_FMAC2 soap_get_mindcall__queryResponse(struct soap *soap, mindcall__queryResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__queryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindcall__queryResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindcall__queryResponse(soap, tag, this, type);
}

SOAP_FMAC1 mindcall__queryResponse * SOAP_FMAC2 soap_in_mindcall__queryResponse(struct soap *soap, const char *tag, mindcall__queryResponse *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindcall__queryResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__queryResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindcall__queryResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindcall__queryResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_mindtype__return1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_mindtype__return1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__PropResult(soap, "mindtype:return", &(((mindcall__queryResponse*)a)->mindtype__return), "mindtype:PropResult"))
				{	soap_flag_mindtype__return1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindcall__queryResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindcall__queryResponse, soap->type, soap->arrayType), SOAP_mindcall__queryResponse, sizeof(mindcall__queryResponse));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindcall__queryResponse * SOAP_FMAC2 soap_instantiate_mindcall__queryResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindcall__queryResponse(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindcall__queryResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindcall__queryResponse*)(cp->ptr = new mindcall__queryResponse);
	else
		return (mindcall__queryResponse*)(cp->ptr = new mindcall__queryResponse[n]);
}

void mindtype__PropResult::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__PropResult))
		this->soap_mark(soap);
}

void mindtype__PropResult::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__PropResult*)this)->schemas, SOAP_mindtype__SchemaArray);
	((mindtype__PropResult*)this)->schemas.soap_mark(soap);
	soap_embedded(soap, &((mindtype__PropResult*)this)->resulttype, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropResult*)this)->resulttype);
	soap_embedded(soap, &((mindtype__PropResult*)this)->propDocuments, SOAP_mindtype__PropDocumentArray);
	((mindtype__PropResult*)this)->propDocuments.soap_mark(soap);
}

void mindtype__PropResult::soap_default()
{
	((mindtype__PropResult*)this)->schemas.soap_default();
	soap_default_xsd__string(&((mindtype__PropResult*)this)->resulttype);
	((mindtype__PropResult*)this)->propDocuments.soap_default();
}

void mindtype__PropResult::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__PropResult, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropResult::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__PropResult(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropResult(struct soap *soap, const char *tag, int id, const mindtype__PropResult *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__PropResult), "mindtype:PropResult");
	(((mindtype__PropResult*)a)->schemas).soap_out(soap, "schemas", -1, "mindtype:SchemaArray");
	soap_out_xsd__string(soap, "resulttype", -1, &(((mindtype__PropResult*)a)->resulttype), "xsd:string");
	(((mindtype__PropResult*)a)->propDocuments).soap_out(soap, "propDocuments", -1, "mindtype:PropDocumentArray");
	soap_element_end_out(soap, tag);
}

void *mindtype__PropResult::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropResult(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropResult * SOAP_FMAC2 soap_get_mindtype__PropResult(struct soap *soap, mindtype__PropResult *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropResult::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropResult(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropResult * SOAP_FMAC2 soap_in_mindtype__PropResult(struct soap *soap, const char *tag, mindtype__PropResult *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropResult *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropResult, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__PropResult)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__PropResult *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_schemas1 = 1, soap_flag_resulttype1 = 1, soap_flag_propDocuments1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_schemas1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropResult*)a)->schemas).soap_in(soap, "schemas", "mindtype:SchemaArray"))
				{	soap_flag_schemas1 = 0;
					continue;
				}

			if (soap_flag_resulttype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "resulttype", &(((mindtype__PropResult*)a)->resulttype), "xsd:string"))
				{	soap_flag_resulttype1 = 0;
					continue;
				}

			if (soap_flag_propDocuments1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropResult*)a)->propDocuments).soap_in(soap, "propDocuments", "mindtype:PropDocumentArray"))
				{	soap_flag_propDocuments1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropResult *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropResult, soap->type, soap->arrayType), SOAP_mindtype__PropResult, sizeof(mindtype__PropResult));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropResult * SOAP_FMAC2 soap_instantiate_mindtype__PropResult(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropResult(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropResult;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropResult*)(cp->ptr = new mindtype__PropResult);
	else
		return (mindtype__PropResult*)(cp->ptr = new mindtype__PropResult[n]);
}

void mindtype__PropDocumentArray::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void mindtype__PropDocumentArray::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, this->__size, SOAP_mindtype__PropDocumentArray))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_mindtype__PropDocument);
			this->__ptr[i].soap_mark(soap);
		}
}

void mindtype__PropDocumentArray::soap_default()
{
	this->__size = 0;
	this->__ptr = NULL;
}

void mindtype__PropDocumentArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, this->__size, SOAP_mindtype__PropDocumentArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropDocumentArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	soap_out_mindtype__PropDocumentArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropDocumentArray(struct soap *soap, const char *tag, int id, const mindtype__PropDocumentArray *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	if (n != 0 && !a->__ptr)
	{	soap_element_null(soap, tag, id, type);
		return;
	}
	i = soap_array_pointer_lookup(soap, a, n, SOAP_mindtype__PropDocumentArray, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return;
		}
		else if (soap_is_single(soap, pp))
			i = 0;
	}
	soap_element_begin_out(soap, tag, id, "mindtype:PropDocumentArray");
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, "mindtype:PropDocument");
	}
	soap_element_end_out(soap, tag);
}

void *mindtype__PropDocumentArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropDocumentArray(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropDocumentArray * SOAP_FMAC2 soap_get_mindtype__PropDocumentArray(struct soap *soap, mindtype__PropDocumentArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropDocumentArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropDocumentArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropDocumentArray(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropDocumentArray * SOAP_FMAC2 soap_in_mindtype__PropDocumentArray(struct soap *soap, const char *tag, mindtype__PropDocumentArray *a, const char *type)
{	int i, j;
	mindtype__PropDocument *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (mindtype__PropDocumentArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentArray, soap->type, soap->arrayType)))
			a->soap_default();
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropDocumentArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentArray, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default();
		a->__size = soap_getsize(soap->arraySize, soap->offset, &j);
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = soap_instantiate_mindtype__PropDocument(soap, a->__size, NULL, NULL);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->soap_default();
			for (i = j; i < j+a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_mindtype__PropDocument(soap, NULL, a->__ptr+i, "mindtype:PropDocument"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{
				p = (mindtype__PropDocument *)soap_push_block(soap, sizeof(mindtype__PropDocument));
				p->mindtype__PropDocument::soap_default();
				if (!soap_in_mindtype__PropDocument(soap, NULL, p, "mindtype:PropDocument"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
			soap_pop_block(soap);
			a->__ptr = soap_instantiate_mindtype__PropDocument(soap, soap->blist->size, NULL, NULL);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropDocumentArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentArray, soap->type, soap->arrayType), SOAP_mindtype__PropDocumentArray, sizeof(mindtype__PropDocumentArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropDocumentArray * SOAP_FMAC2 soap_instantiate_mindtype__PropDocumentArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropDocumentArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropDocumentArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropDocumentArray*)(cp->ptr = new mindtype__PropDocumentArray);
	else
		return (mindtype__PropDocumentArray*)(cp->ptr = new mindtype__PropDocumentArray[n]);
}

void mindtype__PropDocument::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__PropDocument))
		this->soap_mark(soap);
}

void mindtype__PropDocument::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__PropDocument*)this)->documentID, SOAP_mindtype__DocumentID);
	((mindtype__PropDocument*)this)->documentID.soap_mark(soap);
	soap_embedded(soap, &((mindtype__PropDocument*)this)->schemaname, SOAP_PointerToxsd__string);
	soap_mark_PointerToxsd__string(soap, &((mindtype__PropDocument*)this)->schemaname);
	soap_embedded(soap, &((mindtype__PropDocument*)this)->schema, SOAP_PointerTomindtype__Schema);
	soap_mark_PointerTomindtype__Schema(soap, &((mindtype__PropDocument*)this)->schema);
	soap_embedded(soap, &((mindtype__PropDocument*)this)->attributes, SOAP_mindtype__PropDocumentAttributeArray);
	((mindtype__PropDocument*)this)->attributes.soap_mark(soap);
	soap_embedded(soap, &((mindtype__PropDocument*)this)->weight, SOAP_xsd__double);
	soap_embedded(soap, &((mindtype__PropDocument*)this)->originalWeight, SOAP_xsd__double);
}

void mindtype__PropDocument::soap_default()
{
	((mindtype__PropDocument*)this)->documentID.soap_default();
	soap_default_PointerToxsd__string(&((mindtype__PropDocument*)this)->schemaname);
	soap_default_PointerTomindtype__Schema(&((mindtype__PropDocument*)this)->schema);
	((mindtype__PropDocument*)this)->attributes.soap_default();
	soap_default_xsd__double(&((mindtype__PropDocument*)this)->weight);
	soap_default_xsd__double(&((mindtype__PropDocument*)this)->originalWeight);
}

void mindtype__PropDocument::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__PropDocument, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropDocument::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__PropDocument(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropDocument(struct soap *soap, const char *tag, int id, const mindtype__PropDocument *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__PropDocument), "mindtype:PropDocument");
	(((mindtype__PropDocument*)a)->documentID).soap_out(soap, "documentID", -1, "mindtype:DocumentID");
	soap_out_PointerToxsd__string(soap, "schemaname", -1, &(((mindtype__PropDocument*)a)->schemaname), "xsd:string");
	soap_out_PointerTomindtype__Schema(soap, "schema", -1, &(((mindtype__PropDocument*)a)->schema), "mindtype:Schema");
	(((mindtype__PropDocument*)a)->attributes).soap_out(soap, "attributes", -1, "mindtype:PropDocumentAttributeArray");
	soap_out_xsd__double(soap, "weight", -1, &(((mindtype__PropDocument*)a)->weight), "xsd:double");
	soap_out_xsd__double(soap, "originalWeight", -1, &(((mindtype__PropDocument*)a)->originalWeight), "xsd:double");
	soap_element_end_out(soap, tag);
}

void *mindtype__PropDocument::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropDocument(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropDocument * SOAP_FMAC2 soap_get_mindtype__PropDocument(struct soap *soap, mindtype__PropDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropDocument::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropDocument(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropDocument * SOAP_FMAC2 soap_in_mindtype__PropDocument(struct soap *soap, const char *tag, mindtype__PropDocument *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropDocument *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocument, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__PropDocument)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__PropDocument *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_documentID1 = 1, soap_flag_schemaname1 = 1, soap_flag_schema1 = 1, soap_flag_attributes1 = 1, soap_flag_weight1 = 1, soap_flag_originalWeight1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_documentID1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropDocument*)a)->documentID).soap_in(soap, "documentID", "mindtype:DocumentID"))
				{	soap_flag_documentID1 = 0;
					continue;
				}

			if (soap_flag_schemaname1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__string(soap, "schemaname", &(((mindtype__PropDocument*)a)->schemaname), "xsd:string"))
				{	soap_flag_schemaname1 = 0;
					continue;
				}

			if (soap_flag_schema1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__Schema(soap, "schema", &(((mindtype__PropDocument*)a)->schema), "mindtype:Schema"))
				{	soap_flag_schema1 = 0;
					continue;
				}

			if (soap_flag_attributes1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropDocument*)a)->attributes).soap_in(soap, "attributes", "mindtype:PropDocumentAttributeArray"))
				{	soap_flag_attributes1 = 0;
					continue;
				}

			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__double(soap, "weight", &(((mindtype__PropDocument*)a)->weight), "xsd:double"))
				{	soap_flag_weight1 = 0;
					continue;
				}

			if (soap_flag_originalWeight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__double(soap, "originalWeight", &(((mindtype__PropDocument*)a)->originalWeight), "xsd:double"))
				{	soap_flag_originalWeight1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropDocument *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocument, soap->type, soap->arrayType), SOAP_mindtype__PropDocument, sizeof(mindtype__PropDocument));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropDocument * SOAP_FMAC2 soap_instantiate_mindtype__PropDocument(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropDocument(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropDocument;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropDocument*)(cp->ptr = new mindtype__PropDocument);
	else
		return (mindtype__PropDocument*)(cp->ptr = new mindtype__PropDocument[n]);
}

void mindtype__PropDocumentAttributeArray::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void mindtype__PropDocumentAttributeArray::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, this->__size, SOAP_mindtype__PropDocumentAttributeArray))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_mindtype__PropDocumentAttribute);
			this->__ptr[i].soap_mark(soap);
		}
}

void mindtype__PropDocumentAttributeArray::soap_default()
{
	this->__size = 0;
	this->__ptr = NULL;
}

void mindtype__PropDocumentAttributeArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, this->__size, SOAP_mindtype__PropDocumentAttributeArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropDocumentAttributeArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	soap_out_mindtype__PropDocumentAttributeArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropDocumentAttributeArray(struct soap *soap, const char *tag, int id, const mindtype__PropDocumentAttributeArray *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	if (n != 0 && !a->__ptr)
	{	soap_element_null(soap, tag, id, type);
		return;
	}
	i = soap_array_pointer_lookup(soap, a, n, SOAP_mindtype__PropDocumentAttributeArray, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return;
		}
		else if (soap_is_single(soap, pp))
			i = 0;
	}
	soap_element_begin_out(soap, tag, id, "mindtype:PropDocumentAttributeArray");
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, "mindtype:PropDocumentAttribute");
	}
	soap_element_end_out(soap, tag);
}

void *mindtype__PropDocumentAttributeArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropDocumentAttributeArray(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropDocumentAttributeArray * SOAP_FMAC2 soap_get_mindtype__PropDocumentAttributeArray(struct soap *soap, mindtype__PropDocumentAttributeArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropDocumentAttributeArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropDocumentAttributeArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropDocumentAttributeArray(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropDocumentAttributeArray * SOAP_FMAC2 soap_in_mindtype__PropDocumentAttributeArray(struct soap *soap, const char *tag, mindtype__PropDocumentAttributeArray *a, const char *type)
{	int i, j;
	mindtype__PropDocumentAttribute *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (mindtype__PropDocumentAttributeArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentAttributeArray, soap->type, soap->arrayType)))
			a->soap_default();
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropDocumentAttributeArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentAttributeArray, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default();
		a->__size = soap_getsize(soap->arraySize, soap->offset, &j);
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = soap_instantiate_mindtype__PropDocumentAttribute(soap, a->__size, NULL, NULL);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->soap_default();
			for (i = j; i < j+a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_mindtype__PropDocumentAttribute(soap, NULL, a->__ptr+i, "mindtype:PropDocumentAttribute"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{
				p = (mindtype__PropDocumentAttribute *)soap_push_block(soap, sizeof(mindtype__PropDocumentAttribute));
				p->mindtype__PropDocumentAttribute::soap_default();
				if (!soap_in_mindtype__PropDocumentAttribute(soap, NULL, p, "mindtype:PropDocumentAttribute"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
			soap_pop_block(soap);
			a->__ptr = soap_instantiate_mindtype__PropDocumentAttribute(soap, soap->blist->size, NULL, NULL);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropDocumentAttributeArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentAttributeArray, soap->type, soap->arrayType), SOAP_mindtype__PropDocumentAttributeArray, sizeof(mindtype__PropDocumentAttributeArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropDocumentAttributeArray * SOAP_FMAC2 soap_instantiate_mindtype__PropDocumentAttributeArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropDocumentAttributeArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropDocumentAttributeArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropDocumentAttributeArray*)(cp->ptr = new mindtype__PropDocumentAttributeArray);
	else
		return (mindtype__PropDocumentAttributeArray*)(cp->ptr = new mindtype__PropDocumentAttributeArray[n]);
}

void mindtype__PropDocumentAttribute::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__PropDocumentAttribute))
		this->soap_mark(soap);
}

void mindtype__PropDocumentAttribute::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__PropDocumentAttribute*)this)->attributename, SOAP_PointerToxsd__string);
	soap_mark_PointerToxsd__string(soap, &((mindtype__PropDocumentAttribute*)this)->attributename);
	soap_embedded(soap, &((mindtype__PropDocumentAttribute*)this)->attribute, SOAP_PointerTomindtype__SchemaAttribute);
	soap_mark_PointerTomindtype__SchemaAttribute(soap, &((mindtype__PropDocumentAttribute*)this)->attribute);
	soap_embedded(soap, &((mindtype__PropDocumentAttribute*)this)->content, SOAP_mindtype__Content);
	((mindtype__PropDocumentAttribute*)this)->content.soap_mark(soap);
}

void mindtype__PropDocumentAttribute::soap_default()
{
	soap_default_PointerToxsd__string(&((mindtype__PropDocumentAttribute*)this)->attributename);
	soap_default_PointerTomindtype__SchemaAttribute(&((mindtype__PropDocumentAttribute*)this)->attribute);
	((mindtype__PropDocumentAttribute*)this)->content.soap_default();
}

void mindtype__PropDocumentAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__PropDocumentAttribute, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropDocumentAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__PropDocumentAttribute(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropDocumentAttribute(struct soap *soap, const char *tag, int id, const mindtype__PropDocumentAttribute *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__PropDocumentAttribute), "mindtype:PropDocumentAttribute");
	soap_out_PointerToxsd__string(soap, "attributename", -1, &(((mindtype__PropDocumentAttribute*)a)->attributename), "xsd:string");
	soap_out_PointerTomindtype__SchemaAttribute(soap, "attribute", -1, &(((mindtype__PropDocumentAttribute*)a)->attribute), "mindtype:SchemaAttribute");
	(((mindtype__PropDocumentAttribute*)a)->content).soap_out(soap, "content", -1, "mindtype:Content");
	soap_element_end_out(soap, tag);
}

void *mindtype__PropDocumentAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropDocumentAttribute(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropDocumentAttribute * SOAP_FMAC2 soap_get_mindtype__PropDocumentAttribute(struct soap *soap, mindtype__PropDocumentAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropDocumentAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropDocumentAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropDocumentAttribute(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropDocumentAttribute * SOAP_FMAC2 soap_in_mindtype__PropDocumentAttribute(struct soap *soap, const char *tag, mindtype__PropDocumentAttribute *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropDocumentAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentAttribute, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__PropDocumentAttribute)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__PropDocumentAttribute *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_attributename1 = 1, soap_flag_attribute1 = 1, soap_flag_content1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_attributename1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__string(soap, "attributename", &(((mindtype__PropDocumentAttribute*)a)->attributename), "xsd:string"))
				{	soap_flag_attributename1 = 0;
					continue;
				}

			if (soap_flag_attribute1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__SchemaAttribute(soap, "attribute", &(((mindtype__PropDocumentAttribute*)a)->attribute), "mindtype:SchemaAttribute"))
				{	soap_flag_attribute1 = 0;
					continue;
				}

			if (soap_flag_content1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropDocumentAttribute*)a)->content).soap_in(soap, "content", "mindtype:Content"))
				{	soap_flag_content1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropDocumentAttribute *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropDocumentAttribute, soap->type, soap->arrayType), SOAP_mindtype__PropDocumentAttribute, sizeof(mindtype__PropDocumentAttribute));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropDocumentAttribute * SOAP_FMAC2 soap_instantiate_mindtype__PropDocumentAttribute(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropDocumentAttribute(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropDocumentAttribute;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropDocumentAttribute*)(cp->ptr = new mindtype__PropDocumentAttribute);
	else
		return (mindtype__PropDocumentAttribute*)(cp->ptr = new mindtype__PropDocumentAttribute[n]);
}

void mindtype__DocumentID::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__DocumentID))
		this->soap_mark(soap);
}

void mindtype__DocumentID::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__DocumentID*)this)->proxyID, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__DocumentID*)this)->proxyID);
	soap_embedded(soap, &((mindtype__DocumentID*)this)->internalID, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__DocumentID*)this)->internalID);
}

void mindtype__DocumentID::soap_default()
{
	soap_default_xsd__string(&((mindtype__DocumentID*)this)->proxyID);
	soap_default_xsd__string(&((mindtype__DocumentID*)this)->internalID);
}

void mindtype__DocumentID::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__DocumentID, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__DocumentID::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__DocumentID(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__DocumentID(struct soap *soap, const char *tag, int id, const mindtype__DocumentID *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__DocumentID), "mindtype:DocumentID");
	soap_out_xsd__string(soap, "proxyID", -1, &(((mindtype__DocumentID*)a)->proxyID), "xsd:string");
	soap_out_xsd__string(soap, "internalID", -1, &(((mindtype__DocumentID*)a)->internalID), "xsd:string");
	soap_element_end_out(soap, tag);
}

void *mindtype__DocumentID::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__DocumentID(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__DocumentID * SOAP_FMAC2 soap_get_mindtype__DocumentID(struct soap *soap, mindtype__DocumentID *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__DocumentID(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__DocumentID::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__DocumentID(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__DocumentID * SOAP_FMAC2 soap_in_mindtype__DocumentID(struct soap *soap, const char *tag, mindtype__DocumentID *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__DocumentID *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__DocumentID, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__DocumentID)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__DocumentID *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_proxyID1 = 1, soap_flag_internalID1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_proxyID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "proxyID", &(((mindtype__DocumentID*)a)->proxyID), "xsd:string"))
				{	soap_flag_proxyID1 = 0;
					continue;
				}

			if (soap_flag_internalID1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "internalID", &(((mindtype__DocumentID*)a)->internalID), "xsd:string"))
				{	soap_flag_internalID1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__DocumentID *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__DocumentID, soap->type, soap->arrayType), SOAP_mindtype__DocumentID, sizeof(mindtype__DocumentID));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__DocumentID * SOAP_FMAC2 soap_instantiate_mindtype__DocumentID(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__DocumentID(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__DocumentID;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__DocumentID*)(cp->ptr = new mindtype__DocumentID);
	else
		return (mindtype__DocumentID*)(cp->ptr = new mindtype__DocumentID[n]);
}

void mindtype__SchemaArray::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void mindtype__SchemaArray::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, this->__size, SOAP_mindtype__SchemaArray))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_mindtype__Schema);
			this->__ptr[i].soap_mark(soap);
		}
}

void mindtype__SchemaArray::soap_default()
{
	this->__size = 0;
	this->__ptr = NULL;
}

void mindtype__SchemaArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, this->__size, SOAP_mindtype__SchemaArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__SchemaArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	soap_out_mindtype__SchemaArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__SchemaArray(struct soap *soap, const char *tag, int id, const mindtype__SchemaArray *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	if (n != 0 && !a->__ptr)
	{	soap_element_null(soap, tag, id, type);
		return;
	}
	i = soap_array_pointer_lookup(soap, a, n, SOAP_mindtype__SchemaArray, &pp);
	if (i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return;
		}
		else if (soap_is_single(soap, pp))
			i = 0;
	}
	soap_element_begin_out(soap, tag, id, "mindtype:SchemaArray");
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, "mindtype:Schema");
	}
	soap_element_end_out(soap, tag);
}

void *mindtype__SchemaArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__SchemaArray(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__SchemaArray * SOAP_FMAC2 soap_get_mindtype__SchemaArray(struct soap *soap, mindtype__SchemaArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__SchemaArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__SchemaArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__SchemaArray(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__SchemaArray * SOAP_FMAC2 soap_in_mindtype__SchemaArray(struct soap *soap, const char *tag, mindtype__SchemaArray *a, const char *type)
{	int i, j;
	mindtype__Schema *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (mindtype__SchemaArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__SchemaArray, soap->type, soap->arrayType)))
			a->soap_default();
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__SchemaArray *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__SchemaArray, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default();
		a->__size = soap_getsize(soap->arraySize, soap->offset, &j);
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = soap_instantiate_mindtype__Schema(soap, a->__size, NULL, NULL);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->soap_default();
			for (i = j; i < j+a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_mindtype__Schema(soap, NULL, a->__ptr+i, "mindtype:Schema"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{
				p = (mindtype__Schema *)soap_push_block(soap, sizeof(mindtype__Schema));
				p->mindtype__Schema::soap_default();
				if (!soap_in_mindtype__Schema(soap, NULL, p, "mindtype:Schema"))
					if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
			}
			soap_pop_block(soap);
			a->__ptr = soap_instantiate_mindtype__Schema(soap, soap->blist->size, NULL, NULL);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__SchemaArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__SchemaArray, soap->type, soap->arrayType), SOAP_mindtype__SchemaArray, sizeof(mindtype__SchemaArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__SchemaArray * SOAP_FMAC2 soap_instantiate_mindtype__SchemaArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__SchemaArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__SchemaArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__SchemaArray*)(cp->ptr = new mindtype__SchemaArray);
	else
		return (mindtype__SchemaArray*)(cp->ptr = new mindtype__SchemaArray[n]);
}

void mindtype__PropQuery::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__PropQuery))
		this->soap_mark(soap);
}

void mindtype__PropQuery::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__PropQuery*)this)->id, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQuery*)this)->id);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->schema, SOAP_PointerTomindtype__Schema);
	soap_mark_PointerTomindtype__Schema(soap, &((mindtype__PropQuery*)this)->schema);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->userQuery, SOAP_PointerTomindtype__Query);
	soap_mark_PointerTomindtype__Query(soap, &((mindtype__PropQuery*)this)->userQuery);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->numDocs, SOAP_xsd__int);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->resulttype, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQuery*)this)->resulttype);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->costParameters, SOAP_mindtype__CostParameters);
	((mindtype__PropQuery*)this)->costParameters.soap_mark(soap);
	soap_embedded(soap, &((mindtype__PropQuery*)this)->propConditions, SOAP_PropQueryConditionArray);
	((mindtype__PropQuery*)this)->propConditions.soap_mark(soap);
}

void mindtype__PropQuery::soap_default()
{
	soap_default_xsd__string(&((mindtype__PropQuery*)this)->id);
	soap_default_PointerTomindtype__Schema(&((mindtype__PropQuery*)this)->schema);
	soap_default_PointerTomindtype__Query(&((mindtype__PropQuery*)this)->userQuery);
	soap_default_xsd__int(&((mindtype__PropQuery*)this)->numDocs);
	soap_default_xsd__string(&((mindtype__PropQuery*)this)->resulttype);
	((mindtype__PropQuery*)this)->costParameters.soap_default();
	((mindtype__PropQuery*)this)->propConditions.soap_default();
}

void mindtype__PropQuery::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__PropQuery, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropQuery::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__PropQuery(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropQuery(struct soap *soap, const char *tag, int id, const mindtype__PropQuery *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__PropQuery), "mindtype:PropQuery");
	soap_out_xsd__string(soap, "id", -1, &(((mindtype__PropQuery*)a)->id), "xsd:string");
	soap_out_PointerTomindtype__Schema(soap, "schema", -1, &(((mindtype__PropQuery*)a)->schema), "mindtype:Schema");
	soap_out_PointerTomindtype__Query(soap, "userQuery", -1, &(((mindtype__PropQuery*)a)->userQuery), "mindtype:Query");
	soap_out_xsd__int(soap, "numDocs", -1, &(((mindtype__PropQuery*)a)->numDocs), "xsd:int");
	soap_out_xsd__string(soap, "resulttype", -1, &(((mindtype__PropQuery*)a)->resulttype), "xsd:string");
	(((mindtype__PropQuery*)a)->costParameters).soap_out(soap, "costParameters", -1, "mindtype:CostParameters");
	(((mindtype__PropQuery*)a)->propConditions).soap_out(soap, "propConditions", -1, "");
	soap_element_end_out(soap, tag);
}

void *mindtype__PropQuery::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropQuery(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropQuery * SOAP_FMAC2 soap_get_mindtype__PropQuery(struct soap *soap, mindtype__PropQuery *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropQuery(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropQuery::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropQuery(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropQuery * SOAP_FMAC2 soap_in_mindtype__PropQuery(struct soap *soap, const char *tag, mindtype__PropQuery *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropQuery *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropQuery, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__PropQuery)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__PropQuery *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_id1 = 1, soap_flag_schema1 = 1, soap_flag_userQuery1 = 1, soap_flag_numDocs1 = 1, soap_flag_resulttype1 = 1, soap_flag_costParameters1 = 1, soap_flag_propConditions1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_id1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "id", &(((mindtype__PropQuery*)a)->id), "xsd:string"))
				{	soap_flag_id1 = 0;
					continue;
				}

			if (soap_flag_schema1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__Schema(soap, "schema", &(((mindtype__PropQuery*)a)->schema), "mindtype:Schema"))
				{	soap_flag_schema1 = 0;
					continue;
				}

			if (soap_flag_userQuery1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTomindtype__Query(soap, "userQuery", &(((mindtype__PropQuery*)a)->userQuery), "mindtype:Query"))
				{	soap_flag_userQuery1 = 0;
					continue;
				}

			if (soap_flag_numDocs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "numDocs", &(((mindtype__PropQuery*)a)->numDocs), "xsd:int"))
				{	soap_flag_numDocs1 = 0;
					continue;
				}

			if (soap_flag_resulttype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "resulttype", &(((mindtype__PropQuery*)a)->resulttype), "xsd:string"))
				{	soap_flag_resulttype1 = 0;
					continue;
				}

			if (soap_flag_costParameters1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropQuery*)a)->costParameters).soap_in(soap, "costParameters", "mindtype:CostParameters"))
				{	soap_flag_costParameters1 = 0;
					continue;
				}

			if (soap_flag_propConditions1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropQuery*)a)->propConditions).soap_in(soap, "propConditions", ""))
				{	soap_flag_propConditions1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropQuery *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropQuery, soap->type, soap->arrayType), SOAP_mindtype__PropQuery, sizeof(mindtype__PropQuery));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropQuery * SOAP_FMAC2 soap_instantiate_mindtype__PropQuery(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropQuery(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropQuery;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropQuery*)(cp->ptr = new mindtype__PropQuery);
	else
		return (mindtype__PropQuery*)(cp->ptr = new mindtype__PropQuery[n]);
}

void PropQueryConditionArray::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_PropQueryConditionArray))
		this->soap_mark(soap);
}

void PropQueryConditionArray::soap_mark(struct soap *soap) const
{
	if (((PropQueryConditionArray*)this)->propCondition)
	{	int i;
		for (i = 0; i < ((PropQueryConditionArray*)this)->__size; i++)
		{	soap_embedded(soap, ((PropQueryConditionArray*)this)->propCondition + i, SOAP_mindtype__PropQueryCondition);
			((PropQueryConditionArray*)this)->propCondition[i].soap_mark(soap);
		}
	}
}

void PropQueryConditionArray::soap_default()
{
	((PropQueryConditionArray*)this)->__size = 0;
	((PropQueryConditionArray*)this)->propCondition = NULL;
}

void PropQueryConditionArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_PropQueryConditionArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void PropQueryConditionArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_PropQueryConditionArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PropQueryConditionArray(struct soap *soap, const char *tag, int id, const PropQueryConditionArray *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_PropQueryConditionArray), "");
	if (((PropQueryConditionArray*)a)->propCondition)
	{	int i;
		for (i = 0; i < ((PropQueryConditionArray*)a)->__size; i++)
			((PropQueryConditionArray*)a)->propCondition[i].soap_out(soap, "propCondition", -1, "mindtype:PropQueryCondition");
	}
	soap_element_end_out(soap, tag);
}

void *PropQueryConditionArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_PropQueryConditionArray(soap, this, tag, type);
}

SOAP_FMAC1 PropQueryConditionArray * SOAP_FMAC2 soap_get_PropQueryConditionArray(struct soap *soap, PropQueryConditionArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_PropQueryConditionArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *PropQueryConditionArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_PropQueryConditionArray(soap, tag, this, type);
}

SOAP_FMAC1 PropQueryConditionArray * SOAP_FMAC2 soap_in_PropQueryConditionArray(struct soap *soap, const char *tag, PropQueryConditionArray *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (PropQueryConditionArray *)soap_class_id_enter(soap, soap->id, a, SOAP_PropQueryConditionArray, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_PropQueryConditionArray)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (PropQueryConditionArray *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_propCondition1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_propCondition1 && soap->error == SOAP_TAG_MISMATCH)
			{	mindtype__PropQueryCondition *p;
				soap_new_block(soap);
				for (((PropQueryConditionArray*)a)->__size = 0; ; ((PropQueryConditionArray*)a)->__size++)
				{	p = (mindtype__PropQueryCondition *)soap_push_block(soap, sizeof(mindtype__PropQueryCondition));
					p->mindtype__PropQueryCondition::soap_default();
					if (!soap_in_mindtype__PropQueryCondition(soap, "propCondition", p, "mindtype:PropQueryCondition"))
						break;
				}
				soap_pop_block(soap);
				((PropQueryConditionArray*)a)->propCondition = soap_instantiate_mindtype__PropQueryCondition(soap, soap->blist->size, NULL, NULL);
				soap_store_block(soap, (char*)((PropQueryConditionArray*)a)->propCondition);
				soap_flag_propCondition1 = 0;
				if (soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (PropQueryConditionArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_PropQueryConditionArray, soap->type, soap->arrayType), SOAP_PropQueryConditionArray, sizeof(PropQueryConditionArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 PropQueryConditionArray * SOAP_FMAC2 soap_instantiate_PropQueryConditionArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_PropQueryConditionArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_PropQueryConditionArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (PropQueryConditionArray*)(cp->ptr = new PropQueryConditionArray);
	else
		return (PropQueryConditionArray*)(cp->ptr = new PropQueryConditionArray[n]);
}

void mindtype__PropQueryCondition::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__PropQueryCondition))
		this->soap_mark(soap);
}

void mindtype__PropQueryCondition::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->type, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQueryCondition*)this)->type);
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->weight, SOAP_xsd__double);
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->attributename, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQueryCondition*)this)->attributename);
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->predicate, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQueryCondition*)this)->predicate);
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->content, SOAP_mindtype__Content);
	((mindtype__PropQueryCondition*)this)->content.soap_mark(soap);
	soap_embedded(soap, &((mindtype__PropQueryCondition*)this)->mapping, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__PropQueryCondition*)this)->mapping);
}

void mindtype__PropQueryCondition::soap_default()
{
	soap_default_xsd__string(&((mindtype__PropQueryCondition*)this)->type);
	soap_default_xsd__double(&((mindtype__PropQueryCondition*)this)->weight);
	soap_default_xsd__string(&((mindtype__PropQueryCondition*)this)->attributename);
	soap_default_xsd__string(&((mindtype__PropQueryCondition*)this)->predicate);
	((mindtype__PropQueryCondition*)this)->content.soap_default();
	soap_default_xsd__string(&((mindtype__PropQueryCondition*)this)->mapping);
}

void mindtype__PropQueryCondition::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__PropQueryCondition, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__PropQueryCondition::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__PropQueryCondition(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__PropQueryCondition(struct soap *soap, const char *tag, int id, const mindtype__PropQueryCondition *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__PropQueryCondition), "mindtype:PropQueryCondition");
	soap_out_xsd__string(soap, "type", -1, &(((mindtype__PropQueryCondition*)a)->type), "xsd:string");
	soap_out_xsd__double(soap, "weight", -1, &(((mindtype__PropQueryCondition*)a)->weight), "xsd:double");
	soap_out_xsd__string(soap, "attributename", -1, &(((mindtype__PropQueryCondition*)a)->attributename), "xsd:string");
	soap_out_xsd__string(soap, "predicate", -1, &(((mindtype__PropQueryCondition*)a)->predicate), "xsd:string");
	(((mindtype__PropQueryCondition*)a)->content).soap_out(soap, "content", -1, "mindtype:Content");
	soap_out_xsd__string(soap, "mapping", -1, &(((mindtype__PropQueryCondition*)a)->mapping), "xsd:string");
	soap_element_end_out(soap, tag);
}

void *mindtype__PropQueryCondition::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__PropQueryCondition(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__PropQueryCondition * SOAP_FMAC2 soap_get_mindtype__PropQueryCondition(struct soap *soap, mindtype__PropQueryCondition *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__PropQueryCondition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__PropQueryCondition::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__PropQueryCondition(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__PropQueryCondition * SOAP_FMAC2 soap_in_mindtype__PropQueryCondition(struct soap *soap, const char *tag, mindtype__PropQueryCondition *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__PropQueryCondition *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropQueryCondition, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__PropQueryCondition)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__PropQueryCondition *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_type1 = 1, soap_flag_weight1 = 1, soap_flag_attributename1 = 1, soap_flag_predicate1 = 1, soap_flag_content1 = 1, soap_flag_mapping1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "type", &(((mindtype__PropQueryCondition*)a)->type), "xsd:string"))
				{	soap_flag_type1 = 0;
					continue;
				}

			if (soap_flag_weight1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__double(soap, "weight", &(((mindtype__PropQueryCondition*)a)->weight), "xsd:double"))
				{	soap_flag_weight1 = 0;
					continue;
				}

			if (soap_flag_attributename1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "attributename", &(((mindtype__PropQueryCondition*)a)->attributename), "xsd:string"))
				{	soap_flag_attributename1 = 0;
					continue;
				}

			if (soap_flag_predicate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "predicate", &(((mindtype__PropQueryCondition*)a)->predicate), "xsd:string"))
				{	soap_flag_predicate1 = 0;
					continue;
				}

			if (soap_flag_content1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__PropQueryCondition*)a)->content).soap_in(soap, "content", "mindtype:Content"))
				{	soap_flag_content1 = 0;
					continue;
				}

			if (soap_flag_mapping1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "mapping", &(((mindtype__PropQueryCondition*)a)->mapping), "xsd:string"))
				{	soap_flag_mapping1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__PropQueryCondition *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__PropQueryCondition, soap->type, soap->arrayType), SOAP_mindtype__PropQueryCondition, sizeof(mindtype__PropQueryCondition));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__PropQueryCondition * SOAP_FMAC2 soap_instantiate_mindtype__PropQueryCondition(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__PropQueryCondition(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__PropQueryCondition;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__PropQueryCondition*)(cp->ptr = new mindtype__PropQueryCondition);
	else
		return (mindtype__PropQueryCondition*)(cp->ptr = new mindtype__PropQueryCondition[n]);
}

void mindtype__Content::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__Content))
		this->soap_mark(soap);
}

void mindtype__Content::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__Content*)this)->type, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__Content*)this)->type);
	soap_embedded(soap, &((mindtype__Content*)this)->value, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__Content*)this)->value);
}

void mindtype__Content::soap_default()
{
	soap_default_xsd__string(&((mindtype__Content*)this)->type);
	soap_default_xsd__string(&((mindtype__Content*)this)->value);
}

void mindtype__Content::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__Content, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__Content::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__Content(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__Content(struct soap *soap, const char *tag, int id, const mindtype__Content *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__Content), "mindtype:Content");
	soap_out_xsd__string(soap, "type", -1, &(((mindtype__Content*)a)->type), "xsd:string");
	soap_out_xsd__string(soap, "value", -1, &(((mindtype__Content*)a)->value), "xsd:string");
	soap_element_end_out(soap, tag);
}

void *mindtype__Content::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__Content(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__Content * SOAP_FMAC2 soap_get_mindtype__Content(struct soap *soap, mindtype__Content *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__Content(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__Content::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__Content(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__Content * SOAP_FMAC2 soap_in_mindtype__Content(struct soap *soap, const char *tag, mindtype__Content *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__Content *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Content, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__Content)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__Content *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_type1 = 1, soap_flag_value1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "type", &(((mindtype__Content*)a)->type), "xsd:string"))
				{	soap_flag_type1 = 0;
					continue;
				}

			if (soap_flag_value1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "value", &(((mindtype__Content*)a)->value), "xsd:string"))
				{	soap_flag_value1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__Content *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Content, soap->type, soap->arrayType), SOAP_mindtype__Content, sizeof(mindtype__Content));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__Content * SOAP_FMAC2 soap_instantiate_mindtype__Content(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__Content(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__Content;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__Content*)(cp->ptr = new mindtype__Content);
	else
		return (mindtype__Content*)(cp->ptr = new mindtype__Content[n]);
}

void mindtype__CostParameters::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__CostParameters))
		this->soap_mark(soap);
}

void mindtype__CostParameters::soap_mark(struct soap *soap) const
{
}

void mindtype__CostParameters::soap_default()
{
}

void mindtype__CostParameters::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__CostParameters, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__CostParameters::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__CostParameters(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__CostParameters(struct soap *soap, const char *tag, int id, const mindtype__CostParameters *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__CostParameters), "mindtype:CostParameters");
	soap_element_end_out(soap, tag);
}

void *mindtype__CostParameters::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__CostParameters(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__CostParameters * SOAP_FMAC2 soap_get_mindtype__CostParameters(struct soap *soap, mindtype__CostParameters *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__CostParameters(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__CostParameters::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__CostParameters(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__CostParameters * SOAP_FMAC2 soap_in_mindtype__CostParameters(struct soap *soap, const char *tag, mindtype__CostParameters *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__CostParameters *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__CostParameters, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__CostParameters)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__CostParameters *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__CostParameters *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__CostParameters, soap->type, soap->arrayType), SOAP_mindtype__CostParameters, sizeof(mindtype__CostParameters));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__CostParameters * SOAP_FMAC2 soap_instantiate_mindtype__CostParameters(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__CostParameters(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__CostParameters;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__CostParameters*)(cp->ptr = new mindtype__CostParameters);
	else
		return (mindtype__CostParameters*)(cp->ptr = new mindtype__CostParameters[n]);
}

void mindtype__Query::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__Query))
		this->soap_mark(soap);
}

void mindtype__Query::soap_mark(struct soap *soap) const
{
}

void mindtype__Query::soap_default()
{
}

void mindtype__Query::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__Query, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__Query::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__Query(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__Query(struct soap *soap, const char *tag, int id, const mindtype__Query *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__Query), "mindtype:Query");
	soap_element_end_out(soap, tag);
}

void *mindtype__Query::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__Query(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__Query * SOAP_FMAC2 soap_get_mindtype__Query(struct soap *soap, mindtype__Query *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__Query::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__Query(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__Query * SOAP_FMAC2 soap_in_mindtype__Query(struct soap *soap, const char *tag, mindtype__Query *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__Query *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Query, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__Query)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__Query *)a->soap_in(soap, tag, type);
			}
		};
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__Query *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Query, soap->type, soap->arrayType), SOAP_mindtype__Query, sizeof(mindtype__Query));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__Query * SOAP_FMAC2 soap_instantiate_mindtype__Query(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__Query(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__Query;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__Query*)(cp->ptr = new mindtype__Query);
	else
		return (mindtype__Query*)(cp->ptr = new mindtype__Query[n]);
}

void mindtype__Schema::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__Schema))
		this->soap_mark(soap);
}

void mindtype__Schema::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__Schema*)this)->name, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__Schema*)this)->name);
	soap_embedded(soap, &((mindtype__Schema*)this)->attributes, SOAP_PointerToSchemaAttributeArray);
	soap_mark_PointerToSchemaAttributeArray(soap, &((mindtype__Schema*)this)->attributes);
}

void mindtype__Schema::soap_default()
{
	soap_default_xsd__string(&((mindtype__Schema*)this)->name);
	soap_default_PointerToSchemaAttributeArray(&((mindtype__Schema*)this)->attributes);
}

void mindtype__Schema::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__Schema, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__Schema::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__Schema(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__Schema(struct soap *soap, const char *tag, int id, const mindtype__Schema *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__Schema), "mindtype:Schema");
	soap_out_xsd__string(soap, "name", -1, &(((mindtype__Schema*)a)->name), "xsd:string");
	soap_out_PointerToSchemaAttributeArray(soap, "attributes", -1, &(((mindtype__Schema*)a)->attributes), "");
	soap_element_end_out(soap, tag);
}

void *mindtype__Schema::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__Schema(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__Schema * SOAP_FMAC2 soap_get_mindtype__Schema(struct soap *soap, mindtype__Schema *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__Schema(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__Schema::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__Schema(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__Schema * SOAP_FMAC2 soap_in_mindtype__Schema(struct soap *soap, const char *tag, mindtype__Schema *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__Schema *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Schema, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__Schema)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__Schema *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_name1 = 1, soap_flag_attributes1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "name", &(((mindtype__Schema*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_attributes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSchemaAttributeArray(soap, "attributes", &(((mindtype__Schema*)a)->attributes), ""))
				{	soap_flag_attributes1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__Schema *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__Schema, soap->type, soap->arrayType), SOAP_mindtype__Schema, sizeof(mindtype__Schema));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__Schema * SOAP_FMAC2 soap_instantiate_mindtype__Schema(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__Schema(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__Schema;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__Schema*)(cp->ptr = new mindtype__Schema);
	else
		return (mindtype__Schema*)(cp->ptr = new mindtype__Schema[n]);
}

void SchemaAttributeArray::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_SchemaAttributeArray))
		this->soap_mark(soap);
}

void SchemaAttributeArray::soap_mark(struct soap *soap) const
{
	if (((SchemaAttributeArray*)this)->schemaAttribute)
	{	int i;
		for (i = 0; i < ((SchemaAttributeArray*)this)->__size; i++)
		{	soap_embedded(soap, ((SchemaAttributeArray*)this)->schemaAttribute + i, SOAP_PointerTomindtype__SchemaAttribute);
			soap_mark_PointerTomindtype__SchemaAttribute(soap, ((SchemaAttributeArray*)this)->schemaAttribute + i);
		}
	}
}

void SchemaAttributeArray::soap_default()
{
	((SchemaAttributeArray*)this)->__size = 0;
	((SchemaAttributeArray*)this)->schemaAttribute = NULL;
}

void SchemaAttributeArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_SchemaAttributeArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void SchemaAttributeArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_SchemaAttributeArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SchemaAttributeArray(struct soap *soap, const char *tag, int id, const SchemaAttributeArray *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SchemaAttributeArray), "");
	if (((SchemaAttributeArray*)a)->schemaAttribute)
	{	int i;
		for (i = 0; i < ((SchemaAttributeArray*)a)->__size; i++)
			soap_out_PointerTomindtype__SchemaAttribute(soap, "schemaAttribute", -1, ((SchemaAttributeArray*)a)->schemaAttribute + i, "mindtype:SchemaAttribute");
	}
	soap_element_end_out(soap, tag);
}

void *SchemaAttributeArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_SchemaAttributeArray(soap, this, tag, type);
}

SOAP_FMAC1 SchemaAttributeArray * SOAP_FMAC2 soap_get_SchemaAttributeArray(struct soap *soap, SchemaAttributeArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_SchemaAttributeArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *SchemaAttributeArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_SchemaAttributeArray(soap, tag, this, type);
}

SOAP_FMAC1 SchemaAttributeArray * SOAP_FMAC2 soap_in_SchemaAttributeArray(struct soap *soap, const char *tag, SchemaAttributeArray *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (SchemaAttributeArray *)soap_class_id_enter(soap, soap->id, a, SOAP_SchemaAttributeArray, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_SchemaAttributeArray)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (SchemaAttributeArray *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_schemaAttribute1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_schemaAttribute1 && soap->error == SOAP_TAG_MISMATCH)
			{	mindtype__SchemaAttribute **p;
				soap_new_block(soap);
				for (((SchemaAttributeArray*)a)->__size = 0; ; ((SchemaAttributeArray*)a)->__size++)
				{	p = (mindtype__SchemaAttribute **)soap_push_block(soap, sizeof(mindtype__SchemaAttribute *));
					soap_default_PointerTomindtype__SchemaAttribute(p);
					if (!soap_in_PointerTomindtype__SchemaAttribute(soap, "schemaAttribute", p, "mindtype:SchemaAttribute"))
						break;
				}
				soap_pop_block(soap);
				((SchemaAttributeArray*)a)->schemaAttribute = (mindtype__SchemaAttribute **)malloc(soap->blist->size);
				soap_store_block(soap, (char*)((SchemaAttributeArray*)a)->schemaAttribute);
				soap_flag_schemaAttribute1 = 0;
				if (soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (SchemaAttributeArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_SchemaAttributeArray, soap->type, soap->arrayType), SOAP_SchemaAttributeArray, sizeof(SchemaAttributeArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 SchemaAttributeArray * SOAP_FMAC2 soap_instantiate_SchemaAttributeArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_SchemaAttributeArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_SchemaAttributeArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (SchemaAttributeArray*)(cp->ptr = new SchemaAttributeArray);
	else
		return (SchemaAttributeArray*)(cp->ptr = new SchemaAttributeArray[n]);
}

void mindtype__SchemaAttribute::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_mindtype__SchemaAttribute))
		this->soap_mark(soap);
}

void mindtype__SchemaAttribute::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->name, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__SchemaAttribute*)this)->name);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->datatype, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__SchemaAttribute*)this)->datatype);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->domain, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__SchemaAttribute*)this)->domain);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->metadata, SOAP_xsd__boolean);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->sample, SOAP_xsd__boolean);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->surrogate, SOAP_xsd__boolean);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->predicates, SOAP_PredicateArray);
	((mindtype__SchemaAttribute*)this)->predicates.soap_mark(soap);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->mediatype, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__SchemaAttribute*)this)->mediatype);
	soap_embedded(soap, &((mindtype__SchemaAttribute*)this)->description, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &((mindtype__SchemaAttribute*)this)->description);
}

void mindtype__SchemaAttribute::soap_default()
{
	soap_default_xsd__string(&((mindtype__SchemaAttribute*)this)->name);
	soap_default_xsd__string(&((mindtype__SchemaAttribute*)this)->datatype);
	soap_default_xsd__string(&((mindtype__SchemaAttribute*)this)->domain);
	soap_default_xsd__boolean(&((mindtype__SchemaAttribute*)this)->metadata);
	soap_default_xsd__boolean(&((mindtype__SchemaAttribute*)this)->sample);
	soap_default_xsd__boolean(&((mindtype__SchemaAttribute*)this)->surrogate);
	((mindtype__SchemaAttribute*)this)->predicates.soap_default();
	soap_default_xsd__string(&((mindtype__SchemaAttribute*)this)->mediatype);
	soap_default_xsd__string(&((mindtype__SchemaAttribute*)this)->description);
}

void mindtype__SchemaAttribute::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_mindtype__SchemaAttribute, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void mindtype__SchemaAttribute::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_mindtype__SchemaAttribute(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindtype__SchemaAttribute(struct soap *soap, const char *tag, int id, const mindtype__SchemaAttribute *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindtype__SchemaAttribute), "mindtype:SchemaAttribute");
	soap_out_xsd__string(soap, "name", -1, &(((mindtype__SchemaAttribute*)a)->name), "xsd:string");
	soap_out_xsd__string(soap, "datatype", -1, &(((mindtype__SchemaAttribute*)a)->datatype), "xsd:string");
	soap_out_xsd__string(soap, "domain", -1, &(((mindtype__SchemaAttribute*)a)->domain), "xsd:string");
	soap_out_xsd__boolean(soap, "metadata", -1, &(((mindtype__SchemaAttribute*)a)->metadata), "xsd:boolean");
	soap_out_xsd__boolean(soap, "sample", -1, &(((mindtype__SchemaAttribute*)a)->sample), "xsd:boolean");
	soap_out_xsd__boolean(soap, "surrogate", -1, &(((mindtype__SchemaAttribute*)a)->surrogate), "xsd:boolean");
	(((mindtype__SchemaAttribute*)a)->predicates).soap_out(soap, "predicates", -1, "");
	soap_out_xsd__string(soap, "mediatype", -1, &(((mindtype__SchemaAttribute*)a)->mediatype), "xsd:string");
	soap_out_xsd__string(soap, "description", -1, &(((mindtype__SchemaAttribute*)a)->description), "xsd:string");
	soap_element_end_out(soap, tag);
}

void *mindtype__SchemaAttribute::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_mindtype__SchemaAttribute(soap, this, tag, type);
}

SOAP_FMAC1 mindtype__SchemaAttribute * SOAP_FMAC2 soap_get_mindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindtype__SchemaAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *mindtype__SchemaAttribute::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_mindtype__SchemaAttribute(soap, tag, this, type);
}

SOAP_FMAC1 mindtype__SchemaAttribute * SOAP_FMAC2 soap_in_mindtype__SchemaAttribute(struct soap *soap, const char *tag, mindtype__SchemaAttribute *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (mindtype__SchemaAttribute *)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__SchemaAttribute, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_mindtype__SchemaAttribute)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (mindtype__SchemaAttribute *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_name1 = 1, soap_flag_datatype1 = 1, soap_flag_domain1 = 1, soap_flag_metadata1 = 1, soap_flag_sample1 = 1, soap_flag_surrogate1 = 1, soap_flag_predicates1 = 1, soap_flag_mediatype1 = 1, soap_flag_description1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_name1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "name", &(((mindtype__SchemaAttribute*)a)->name), "xsd:string"))
				{	soap_flag_name1 = 0;
					continue;
				}

			if (soap_flag_datatype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "datatype", &(((mindtype__SchemaAttribute*)a)->datatype), "xsd:string"))
				{	soap_flag_datatype1 = 0;
					continue;
				}

			if (soap_flag_domain1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "domain", &(((mindtype__SchemaAttribute*)a)->domain), "xsd:string"))
				{	soap_flag_domain1 = 0;
					continue;
				}

			if (soap_flag_metadata1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "metadata", &(((mindtype__SchemaAttribute*)a)->metadata), "xsd:boolean"))
				{	soap_flag_metadata1 = 0;
					continue;
				}

			if (soap_flag_sample1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "sample", &(((mindtype__SchemaAttribute*)a)->sample), "xsd:boolean"))
				{	soap_flag_sample1 = 0;
					continue;
				}

			if (soap_flag_surrogate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "surrogate", &(((mindtype__SchemaAttribute*)a)->surrogate), "xsd:boolean"))
				{	soap_flag_surrogate1 = 0;
					continue;
				}

			if (soap_flag_predicates1 && soap->error == SOAP_TAG_MISMATCH)
				if ((((mindtype__SchemaAttribute*)a)->predicates).soap_in(soap, "predicates", ""))
				{	soap_flag_predicates1 = 0;
					continue;
				}

			if (soap_flag_mediatype1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "mediatype", &(((mindtype__SchemaAttribute*)a)->mediatype), "xsd:string"))
				{	soap_flag_mediatype1 = 0;
					continue;
				}

			if (soap_flag_description1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "description", &(((mindtype__SchemaAttribute*)a)->description), "xsd:string"))
				{	soap_flag_description1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (mindtype__SchemaAttribute *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_mindtype__SchemaAttribute, soap->type, soap->arrayType), SOAP_mindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 mindtype__SchemaAttribute * SOAP_FMAC2 soap_instantiate_mindtype__SchemaAttribute(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_mindtype__SchemaAttribute(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_mindtype__SchemaAttribute;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (mindtype__SchemaAttribute*)(cp->ptr = new mindtype__SchemaAttribute);
	else
		return (mindtype__SchemaAttribute*)(cp->ptr = new mindtype__SchemaAttribute[n]);
}

void PredicateArray::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_PredicateArray))
		this->soap_mark(soap);
}

void PredicateArray::soap_mark(struct soap *soap) const
{
	if (((PredicateArray*)this)->predicate)
	{	int i;
		for (i = 0; i < ((PredicateArray*)this)->__size; i++)
		{	soap_embedded(soap, ((PredicateArray*)this)->predicate + i, SOAP_xsd__string);
			soap_mark_xsd__string(soap, ((PredicateArray*)this)->predicate + i);
		}
	}
}

void PredicateArray::soap_default()
{
	((PredicateArray*)this)->__size = 0;
	((PredicateArray*)this)->predicate = NULL;
}

void PredicateArray::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_PredicateArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	soap_putindependent(soap);
}

void PredicateArray::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	soap_out_PredicateArray(soap, tag, id, this, type);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PredicateArray(struct soap *soap, const char *tag, int id, const PredicateArray *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_PredicateArray), "");
	if (((PredicateArray*)a)->predicate)
	{	int i;
		for (i = 0; i < ((PredicateArray*)a)->__size; i++)
			soap_out_xsd__string(soap, "predicate", -1, ((PredicateArray*)a)->predicate + i, "xsd:string");
	}
	soap_element_end_out(soap, tag);
}

void *PredicateArray::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_PredicateArray(soap, this, tag, type);
}

SOAP_FMAC1 PredicateArray * SOAP_FMAC2 soap_get_PredicateArray(struct soap *soap, PredicateArray *p, const char *tag, const char *type)
{
	if ((p = soap_in_PredicateArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *PredicateArray::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_PredicateArray(soap, tag, this, type);
}

SOAP_FMAC1 PredicateArray * SOAP_FMAC2 soap_in_PredicateArray(struct soap *soap, const char *tag, PredicateArray *a, const char *type)
{
	void *p = soap->alist;
	short f;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (soap->body && !*soap->href)
	{	if (!(a = (PredicateArray *)soap_class_id_enter(soap, soap->id, a, SOAP_PredicateArray, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if ((f = soap->alloced))
		{	a->soap_default();
			if (soap->clist->type != SOAP_PredicateArray)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (PredicateArray *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_predicate1 = 1;
		for(;;)
		{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_predicate1 && soap->error == SOAP_TAG_MISMATCH)
			{	char **p;
				soap_new_block(soap);
				for (((PredicateArray*)a)->__size = 0; ; ((PredicateArray*)a)->__size++)
				{	p = (char **)soap_push_block(soap, sizeof(char *));
					soap_default_xsd__string(p);
					if (!soap_in_xsd__string(soap, "predicate", p, "xsd:string"))
						break;
				}
				soap_pop_block(soap);
				((PredicateArray*)a)->predicate = (char **)malloc(soap->blist->size);
				soap_store_block(soap, (char*)((PredicateArray*)a)->predicate);
				soap_flag_predicate1 = 0;
				if (soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	if (f)
					delete a;
				soap_dealloc(soap, p);
				return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (PredicateArray *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_PredicateArray, soap->type, soap->arrayType), SOAP_PredicateArray, sizeof(PredicateArray));
		if (soap->alloced)
			a->soap_default();
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 PredicateArray * SOAP_FMAC2 soap_instantiate_PredicateArray(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST,SOAP_MESSAGE(fdebug,"\nsoap_instantiate_PredicateArray(%d, %s)\n", n, type?type:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_PredicateArray;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
		return (PredicateArray*)(cp->ptr = new PredicateArray);
	else
		return (PredicateArray*)(cp->ptr = new PredicateArray[n]);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_string);
	soap_mark_string(soap, &a->detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct SOAP_ENV__Fault *a)
{
	soap_default_string(&a->faultcode);
	soap_default_string(&a->faultstring);
	soap_default_string(&a->faultactor);
	soap_default_string(&a->detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct SOAP_ENV__Header *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_SOAP_ENV__Header), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__constructResourceDescription(struct soap *soap, struct mindcall__constructResourceDescription const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__constructResourceDescription))
		soap_mark_mindcall__constructResourceDescription(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__constructResourceDescription(struct soap *soap, const struct mindcall__constructResourceDescription *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__constructResourceDescription(struct mindcall__constructResourceDescription *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__constructResourceDescription(struct soap *soap, struct mindcall__constructResourceDescription *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__constructResourceDescription, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__constructResourceDescription(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__constructResourceDescription(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__constructResourceDescription(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__constructResourceDescription(struct soap *soap, const char *tag, int id, const struct mindcall__constructResourceDescription *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__constructResourceDescription), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__constructResourceDescription * SOAP_FMAC2 soap_get_mindcall__constructResourceDescription(struct soap *soap, struct mindcall__constructResourceDescription *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__constructResourceDescription(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__constructResourceDescription * SOAP_FMAC2 soap_in_mindcall__constructResourceDescription(struct soap *soap, const char *tag, struct mindcall__constructResourceDescription *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__constructResourceDescription *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__constructResourceDescription, sizeof(struct mindcall__constructResourceDescription), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__constructResourceDescription(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__constructResourceDescription *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__constructResourceDescription, sizeof(struct mindcall__constructResourceDescription), 0), SOAP_mindcall__constructResourceDescription, sizeof(struct mindcall__constructResourceDescription));
		if (soap->alloced)
			soap_default_mindcall__constructResourceDescription(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__addDocument(struct soap *soap, struct mindcall__addDocument const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__addDocument))
		soap_mark_mindcall__addDocument(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__addDocument(struct soap *soap, const struct mindcall__addDocument *a)
{
	soap_embedded(soap, &a->propDocument, SOAP_mindtype__PropDocument);
	a->propDocument.soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__addDocument(struct mindcall__addDocument *a)
{
	a->propDocument.soap_default();
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__addDocument(struct soap *soap, struct mindcall__addDocument *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__addDocument, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__addDocument(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__addDocument(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__addDocument(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__addDocument(struct soap *soap, const char *tag, int id, const struct mindcall__addDocument *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__addDocument), type);
	a->propDocument.soap_out(soap, "propDocument", -1, "mindtype:PropDocument");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__addDocument * SOAP_FMAC2 soap_get_mindcall__addDocument(struct soap *soap, struct mindcall__addDocument *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__addDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__addDocument * SOAP_FMAC2 soap_in_mindcall__addDocument(struct soap *soap, const char *tag, struct mindcall__addDocument *a, const char *type)
{
	short soap_flag_propDocument = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__addDocument *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__addDocument, sizeof(struct mindcall__addDocument), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__addDocument(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_propDocument && soap->error == SOAP_TAG_MISMATCH)
				if (a->propDocument.soap_in(soap, "propDocument", "mindtype:PropDocument"))
				{	soap_flag_propDocument = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__addDocument *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__addDocument, sizeof(struct mindcall__addDocument), 0), SOAP_mindcall__addDocument, sizeof(struct mindcall__addDocument));
		if (soap->alloced)
			soap_default_mindcall__addDocument(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__clearDocuments(struct soap *soap, struct mindcall__clearDocuments const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__clearDocuments))
		soap_mark_mindcall__clearDocuments(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__clearDocuments(struct soap *soap, const struct mindcall__clearDocuments *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__clearDocuments(struct mindcall__clearDocuments *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__clearDocuments(struct soap *soap, struct mindcall__clearDocuments *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__clearDocuments, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__clearDocuments(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__clearDocuments(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__clearDocuments(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__clearDocuments(struct soap *soap, const char *tag, int id, const struct mindcall__clearDocuments *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__clearDocuments), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__clearDocuments * SOAP_FMAC2 soap_get_mindcall__clearDocuments(struct soap *soap, struct mindcall__clearDocuments *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__clearDocuments(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__clearDocuments * SOAP_FMAC2 soap_in_mindcall__clearDocuments(struct soap *soap, const char *tag, struct mindcall__clearDocuments *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__clearDocuments *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__clearDocuments, sizeof(struct mindcall__clearDocuments), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__clearDocuments(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__clearDocuments *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__clearDocuments, sizeof(struct mindcall__clearDocuments), 0), SOAP_mindcall__clearDocuments, sizeof(struct mindcall__clearDocuments));
		if (soap->alloced)
			soap_default_mindcall__clearDocuments(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__setCollectionNumDocs(struct soap *soap, struct mindcall__setCollectionNumDocs const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__setCollectionNumDocs))
		soap_mark_mindcall__setCollectionNumDocs(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__setCollectionNumDocs(struct soap *soap, const struct mindcall__setCollectionNumDocs *a)
{
	soap_embedded(soap, &a->nums, SOAP_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__setCollectionNumDocs(struct mindcall__setCollectionNumDocs *a)
{
	soap_default_xsd__int(&a->nums);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__setCollectionNumDocs(struct soap *soap, struct mindcall__setCollectionNumDocs *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__setCollectionNumDocs, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__setCollectionNumDocs(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__setCollectionNumDocs(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__setCollectionNumDocs(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__setCollectionNumDocs(struct soap *soap, const char *tag, int id, const struct mindcall__setCollectionNumDocs *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__setCollectionNumDocs), type);
	soap_out_xsd__int(soap, "nums", -1, &a->nums, "xsd:int");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__setCollectionNumDocs * SOAP_FMAC2 soap_get_mindcall__setCollectionNumDocs(struct soap *soap, struct mindcall__setCollectionNumDocs *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__setCollectionNumDocs(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__setCollectionNumDocs * SOAP_FMAC2 soap_in_mindcall__setCollectionNumDocs(struct soap *soap, const char *tag, struct mindcall__setCollectionNumDocs *a, const char *type)
{
	short soap_flag_nums = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__setCollectionNumDocs *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__setCollectionNumDocs, sizeof(struct mindcall__setCollectionNumDocs), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__setCollectionNumDocs(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_nums && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "nums", &a->nums, "xsd:int"))
				{	soap_flag_nums = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__setCollectionNumDocs *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__setCollectionNumDocs, sizeof(struct mindcall__setCollectionNumDocs), 0), SOAP_mindcall__setCollectionNumDocs, sizeof(struct mindcall__setCollectionNumDocs));
		if (soap->alloced)
			soap_default_mindcall__setCollectionNumDocs(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__getSchema(struct soap *soap, struct mindcall__getSchema const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__getSchema))
		soap_mark_mindcall__getSchema(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__getSchema(struct soap *soap, const struct mindcall__getSchema *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__getSchema(struct mindcall__getSchema *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__getSchema(struct soap *soap, struct mindcall__getSchema *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__getSchema, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__getSchema(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__getSchema(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__getSchema(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__getSchema(struct soap *soap, const char *tag, int id, const struct mindcall__getSchema *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__getSchema), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__getSchema * SOAP_FMAC2 soap_get_mindcall__getSchema(struct soap *soap, struct mindcall__getSchema *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__getSchema(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__getSchema * SOAP_FMAC2 soap_in_mindcall__getSchema(struct soap *soap, const char *tag, struct mindcall__getSchema *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__getSchema *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getSchema, sizeof(struct mindcall__getSchema), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__getSchema(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__getSchema *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getSchema, sizeof(struct mindcall__getSchema), 0), SOAP_mindcall__getSchema, sizeof(struct mindcall__getSchema));
		if (soap->alloced)
			soap_default_mindcall__getSchema(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__extractQBSFeatures(struct soap *soap, struct mindcall__extractQBSFeatures const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__extractQBSFeatures))
		soap_mark_mindcall__extractQBSFeatures(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__extractQBSFeatures(struct soap *soap, const struct mindcall__extractQBSFeatures *a)
{
	soap_embedded(soap, &a->propDocumentAttribute, SOAP_mindtype__PropDocumentAttribute);
	a->propDocumentAttribute.soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__extractQBSFeatures(struct mindcall__extractQBSFeatures *a)
{
	a->propDocumentAttribute.soap_default();
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__extractQBSFeatures(struct soap *soap, struct mindcall__extractQBSFeatures *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__extractQBSFeatures, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__extractQBSFeatures(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__extractQBSFeatures(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__extractQBSFeatures(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__extractQBSFeatures(struct soap *soap, const char *tag, int id, const struct mindcall__extractQBSFeatures *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__extractQBSFeatures), type);
	a->propDocumentAttribute.soap_out(soap, "propDocumentAttribute", -1, "mindtype:PropDocumentAttribute");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__extractQBSFeatures * SOAP_FMAC2 soap_get_mindcall__extractQBSFeatures(struct soap *soap, struct mindcall__extractQBSFeatures *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__extractQBSFeatures(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__extractQBSFeatures * SOAP_FMAC2 soap_in_mindcall__extractQBSFeatures(struct soap *soap, const char *tag, struct mindcall__extractQBSFeatures *a, const char *type)
{
	short soap_flag_propDocumentAttribute = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__extractQBSFeatures *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__extractQBSFeatures, sizeof(struct mindcall__extractQBSFeatures), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__extractQBSFeatures(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_propDocumentAttribute && soap->error == SOAP_TAG_MISMATCH)
				if (a->propDocumentAttribute.soap_in(soap, "propDocumentAttribute", "mindtype:PropDocumentAttribute"))
				{	soap_flag_propDocumentAttribute = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__extractQBSFeatures *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__extractQBSFeatures, sizeof(struct mindcall__extractQBSFeatures), 0), SOAP_mindcall__extractQBSFeatures, sizeof(struct mindcall__extractQBSFeatures));
		if (soap->alloced)
			soap_default_mindcall__extractQBSFeatures(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__query(struct soap *soap, struct mindcall__query const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__query))
		soap_mark_mindcall__query(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__query(struct soap *soap, const struct mindcall__query *a)
{
	soap_embedded(soap, &a->propQuery, SOAP_mindtype__PropQuery);
	a->propQuery.soap_mark(soap);
	soap_embedded(soap, &a->numDocs, SOAP_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__query(struct mindcall__query *a)
{
	a->propQuery.soap_default();
	soap_default_xsd__int(&a->numDocs);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__query(struct soap *soap, struct mindcall__query *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__query, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__query(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__query(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__query(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__query(struct soap *soap, const char *tag, int id, const struct mindcall__query *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__query), type);
	a->propQuery.soap_out(soap, "propQuery", -1, "mindtype:PropQuery");
	soap_out_xsd__int(soap, "numDocs", -1, &a->numDocs, "xsd:int");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__query * SOAP_FMAC2 soap_get_mindcall__query(struct soap *soap, struct mindcall__query *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__query * SOAP_FMAC2 soap_in_mindcall__query(struct soap *soap, const char *tag, struct mindcall__query *a, const char *type)
{
	short soap_flag_propQuery = 1, soap_flag_numDocs = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__query *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__query, sizeof(struct mindcall__query), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__query(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_propQuery && soap->error == SOAP_TAG_MISMATCH)
				if (a->propQuery.soap_in(soap, "propQuery", "mindtype:PropQuery"))
				{	soap_flag_propQuery = 0;
					continue;
				}
			if (soap_flag_numDocs && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "numDocs", &a->numDocs, "xsd:int"))
				{	soap_flag_numDocs = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__query *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__query, sizeof(struct mindcall__query), 0), SOAP_mindcall__query, sizeof(struct mindcall__query));
		if (soap->alloced)
			soap_default_mindcall__query(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__retrieveURL(struct soap *soap, struct mindcall__retrieveURL const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__retrieveURL))
		soap_mark_mindcall__retrieveURL(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__retrieveURL(struct soap *soap, const struct mindcall__retrieveURL *a)
{
	soap_embedded(soap, &a->service, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->service);
	soap_embedded(soap, &a->callerService, SOAP_xsd__string);
	soap_mark_xsd__string(soap, &a->callerService);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__retrieveURL(struct mindcall__retrieveURL *a)
{
	soap_default_xsd__string(&a->service);
	soap_default_xsd__string(&a->callerService);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__retrieveURL(struct soap *soap, struct mindcall__retrieveURL *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__retrieveURL, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__retrieveURL(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__retrieveURL(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__retrieveURL(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__retrieveURL(struct soap *soap, const char *tag, int id, const struct mindcall__retrieveURL *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__retrieveURL), type);
	soap_out_xsd__string(soap, "service", -1, &a->service, "xsd:string");
	soap_out_xsd__string(soap, "callerService", -1, &a->callerService, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__retrieveURL * SOAP_FMAC2 soap_get_mindcall__retrieveURL(struct soap *soap, struct mindcall__retrieveURL *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__retrieveURL(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__retrieveURL * SOAP_FMAC2 soap_in_mindcall__retrieveURL(struct soap *soap, const char *tag, struct mindcall__retrieveURL *a, const char *type)
{
	short soap_flag_service = 1, soap_flag_callerService = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__retrieveURL *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__retrieveURL, sizeof(struct mindcall__retrieveURL), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__retrieveURL(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_service && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "service", &a->service, "xsd:string"))
				{	soap_flag_service = 0;
					continue;
				}
			if (soap_flag_callerService && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "callerService", &a->callerService, "xsd:string"))
				{	soap_flag_callerService = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__retrieveURL *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__retrieveURL, sizeof(struct mindcall__retrieveURL), 0), SOAP_mindcall__retrieveURL, sizeof(struct mindcall__retrieveURL));
		if (soap->alloced)
			soap_default_mindcall__retrieveURL(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__retrieveURLResponse(struct soap *soap, struct mindcall__retrieveURLResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__retrieveURLResponse))
		soap_mark_mindcall__retrieveURLResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__retrieveURLResponse(struct soap *soap, const struct mindcall__retrieveURLResponse *a)
{
	soap_embedded(soap, &a->return_, SOAP_PointerToxsd__string);
	soap_mark_PointerToxsd__string(soap, &a->return_);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__retrieveURLResponse(struct mindcall__retrieveURLResponse *a)
{
	soap_default_PointerToxsd__string(&a->return_);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__retrieveURLResponse(struct soap *soap, struct mindcall__retrieveURLResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__retrieveURLResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__retrieveURLResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__retrieveURLResponse(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__retrieveURLResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__retrieveURLResponse(struct soap *soap, const char *tag, int id, const struct mindcall__retrieveURLResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__retrieveURLResponse), type);
	soap_out_PointerToxsd__string(soap, "return", -1, &a->return_, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__retrieveURLResponse * SOAP_FMAC2 soap_get_mindcall__retrieveURLResponse(struct soap *soap, struct mindcall__retrieveURLResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__retrieveURLResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__retrieveURLResponse * SOAP_FMAC2 soap_in_mindcall__retrieveURLResponse(struct soap *soap, const char *tag, struct mindcall__retrieveURLResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__retrieveURLResponse *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__retrieveURLResponse, sizeof(struct mindcall__retrieveURLResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__retrieveURLResponse(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_ = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__retrieveURLResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__retrieveURLResponse, sizeof(struct mindcall__retrieveURLResponse), 0), SOAP_mindcall__retrieveURLResponse, sizeof(struct mindcall__retrieveURLResponse));
		if (soap->alloced)
			soap_default_mindcall__retrieveURLResponse(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__getInternalStatus(struct soap *soap, struct mindcall__getInternalStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__getInternalStatus))
		soap_mark_mindcall__getInternalStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__getInternalStatus(struct soap *soap, const struct mindcall__getInternalStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__getInternalStatus(struct mindcall__getInternalStatus *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__getInternalStatus(struct soap *soap, struct mindcall__getInternalStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__getInternalStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__getInternalStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__getInternalStatus(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__getInternalStatus(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__getInternalStatus(struct soap *soap, const char *tag, int id, const struct mindcall__getInternalStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__getInternalStatus), type);
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__getInternalStatus * SOAP_FMAC2 soap_get_mindcall__getInternalStatus(struct soap *soap, struct mindcall__getInternalStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__getInternalStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__getInternalStatus * SOAP_FMAC2 soap_in_mindcall__getInternalStatus(struct soap *soap, const char *tag, struct mindcall__getInternalStatus *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__getInternalStatus *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getInternalStatus, sizeof(struct mindcall__getInternalStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__getInternalStatus(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__getInternalStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getInternalStatus, sizeof(struct mindcall__getInternalStatus), 0), SOAP_mindcall__getInternalStatus, sizeof(struct mindcall__getInternalStatus));
		if (soap->alloced)
			soap_default_mindcall__getInternalStatus(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_mindcall__getInternalStatusResponse(struct soap *soap, struct mindcall__getInternalStatusResponse const*a)
{
	if (!soap_reference(soap, a, SOAP_mindcall__getInternalStatusResponse))
		soap_mark_mindcall__getInternalStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_mindcall__getInternalStatusResponse(struct soap *soap, const struct mindcall__getInternalStatusResponse *a)
{
	soap_embedded(soap, &a->return_, SOAP_PointerToxsd__string);
	soap_mark_PointerToxsd__string(soap, &a->return_);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_mindcall__getInternalStatusResponse(struct mindcall__getInternalStatusResponse *a)
{
	soap_default_PointerToxsd__string(&a->return_);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_mindcall__getInternalStatusResponse(struct soap *soap, struct mindcall__getInternalStatusResponse *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_mindcall__getInternalStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_mindcall__getInternalStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_mindcall__getInternalStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_mindcall__getInternalStatusResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_mindcall__getInternalStatusResponse(struct soap *soap, const char *tag, int id, const struct mindcall__getInternalStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_mindcall__getInternalStatusResponse), type);
	soap_out_PointerToxsd__string(soap, "return", -1, &a->return_, "xsd:string");
	soap_element_end_out(soap, tag);
}

SOAP_FMAC1 struct mindcall__getInternalStatusResponse * SOAP_FMAC2 soap_get_mindcall__getInternalStatusResponse(struct soap *soap, struct mindcall__getInternalStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_mindcall__getInternalStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct mindcall__getInternalStatusResponse * SOAP_FMAC2 soap_in_mindcall__getInternalStatusResponse(struct soap *soap, const char *tag, struct mindcall__getInternalStatusResponse *a, const char *type)
{
	short soap_flag_return_ = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->enable_null)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (struct mindcall__getInternalStatusResponse *)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getInternalStatusResponse, sizeof(struct mindcall__getInternalStatusResponse), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_mindcall__getInternalStatusResponse(a);
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_return_ && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToxsd__string(soap, "return", &a->return_, "xsd:string"))
				{	soap_flag_return_ = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct mindcall__getInternalStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_mindcall__getInternalStatusResponse, sizeof(struct mindcall__getInternalStatusResponse), 0), SOAP_mindcall__getInternalStatusResponse, sizeof(struct mindcall__getInternalStatusResponse));
		if (soap->alloced)
			soap_default_mindcall__getInternalStatusResponse(a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, mindcall__constructResourceDescriptionResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__constructResourceDescriptionResponse))
		soap_mark_PointerTomindcall__constructResourceDescriptionResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, mindcall__constructResourceDescriptionResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__constructResourceDescriptionResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__constructResourceDescriptionResponse(mindcall__constructResourceDescriptionResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, mindcall__constructResourceDescriptionResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__constructResourceDescriptionResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__constructResourceDescriptionResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__constructResourceDescriptionResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__constructResourceDescriptionResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, const char *tag, int id, mindcall__constructResourceDescriptionResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__constructResourceDescriptionResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__constructResourceDescriptionResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__constructResourceDescriptionResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__constructResourceDescriptionResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__constructResourceDescriptionResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, mindcall__constructResourceDescriptionResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__constructResourceDescriptionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__constructResourceDescriptionResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__constructResourceDescriptionResponse(struct soap *soap, const char *tag, mindcall__constructResourceDescriptionResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__constructResourceDescriptionResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__constructResourceDescriptionResponse, sizeof(mindcall__constructResourceDescriptionResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__constructResourceDescriptionResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__constructResourceDescriptionResponse, sizeof(mindcall__constructResourceDescriptionResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__constructResourceDescriptionResponse *)soap_instantiate_mindcall__constructResourceDescriptionResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__constructResourceDescriptionResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__constructResourceDescriptionResponse, sizeof(mindcall__constructResourceDescriptionResponse *), 1), SOAP_mindcall__constructResourceDescriptionResponse, sizeof(mindcall__constructResourceDescriptionResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__addDocumentResponse(struct soap *soap, mindcall__addDocumentResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__addDocumentResponse))
		soap_mark_PointerTomindcall__addDocumentResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__addDocumentResponse(struct soap *soap, mindcall__addDocumentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__addDocumentResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__addDocumentResponse(mindcall__addDocumentResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__addDocumentResponse(struct soap *soap, mindcall__addDocumentResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__addDocumentResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__addDocumentResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__addDocumentResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__addDocumentResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__addDocumentResponse(struct soap *soap, const char *tag, int id, mindcall__addDocumentResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__addDocumentResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__addDocumentResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__addDocumentResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__addDocumentResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__addDocumentResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__addDocumentResponse(struct soap *soap, mindcall__addDocumentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__addDocumentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__addDocumentResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__addDocumentResponse(struct soap *soap, const char *tag, mindcall__addDocumentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__addDocumentResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__addDocumentResponse, sizeof(mindcall__addDocumentResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__addDocumentResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__addDocumentResponse, sizeof(mindcall__addDocumentResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__addDocumentResponse *)soap_instantiate_mindcall__addDocumentResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__addDocumentResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__addDocumentResponse, sizeof(mindcall__addDocumentResponse *), 1), SOAP_mindcall__addDocumentResponse, sizeof(mindcall__addDocumentResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__clearDocumentsResponse(struct soap *soap, mindcall__clearDocumentsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__clearDocumentsResponse))
		soap_mark_PointerTomindcall__clearDocumentsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__clearDocumentsResponse(struct soap *soap, mindcall__clearDocumentsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__clearDocumentsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__clearDocumentsResponse(mindcall__clearDocumentsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__clearDocumentsResponse(struct soap *soap, mindcall__clearDocumentsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__clearDocumentsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__clearDocumentsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__clearDocumentsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__clearDocumentsResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__clearDocumentsResponse(struct soap *soap, const char *tag, int id, mindcall__clearDocumentsResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__clearDocumentsResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__clearDocumentsResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__clearDocumentsResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__clearDocumentsResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__clearDocumentsResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__clearDocumentsResponse(struct soap *soap, mindcall__clearDocumentsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__clearDocumentsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__clearDocumentsResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__clearDocumentsResponse(struct soap *soap, const char *tag, mindcall__clearDocumentsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__clearDocumentsResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__clearDocumentsResponse, sizeof(mindcall__clearDocumentsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__clearDocumentsResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__clearDocumentsResponse, sizeof(mindcall__clearDocumentsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__clearDocumentsResponse *)soap_instantiate_mindcall__clearDocumentsResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__clearDocumentsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__clearDocumentsResponse, sizeof(mindcall__clearDocumentsResponse *), 1), SOAP_mindcall__clearDocumentsResponse, sizeof(mindcall__clearDocumentsResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, mindcall__setCollectionNumDocsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__setCollectionNumDocsResponse))
		soap_mark_PointerTomindcall__setCollectionNumDocsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, mindcall__setCollectionNumDocsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__setCollectionNumDocsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__setCollectionNumDocsResponse(mindcall__setCollectionNumDocsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, mindcall__setCollectionNumDocsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__setCollectionNumDocsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__setCollectionNumDocsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__setCollectionNumDocsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__setCollectionNumDocsResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, const char *tag, int id, mindcall__setCollectionNumDocsResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__setCollectionNumDocsResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__setCollectionNumDocsResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__setCollectionNumDocsResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__setCollectionNumDocsResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__setCollectionNumDocsResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, mindcall__setCollectionNumDocsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__setCollectionNumDocsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__setCollectionNumDocsResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__setCollectionNumDocsResponse(struct soap *soap, const char *tag, mindcall__setCollectionNumDocsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__setCollectionNumDocsResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__setCollectionNumDocsResponse, sizeof(mindcall__setCollectionNumDocsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__setCollectionNumDocsResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__setCollectionNumDocsResponse, sizeof(mindcall__setCollectionNumDocsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__setCollectionNumDocsResponse *)soap_instantiate_mindcall__setCollectionNumDocsResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__setCollectionNumDocsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__setCollectionNumDocsResponse, sizeof(mindcall__setCollectionNumDocsResponse *), 1), SOAP_mindcall__setCollectionNumDocsResponse, sizeof(mindcall__setCollectionNumDocsResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__getSchemaResponse(struct soap *soap, mindcall__getSchemaResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__getSchemaResponse))
		soap_mark_PointerTomindcall__getSchemaResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__getSchemaResponse(struct soap *soap, mindcall__getSchemaResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__getSchemaResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__getSchemaResponse(mindcall__getSchemaResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__getSchemaResponse(struct soap *soap, mindcall__getSchemaResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__getSchemaResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__getSchemaResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__getSchemaResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__getSchemaResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__getSchemaResponse(struct soap *soap, const char *tag, int id, mindcall__getSchemaResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__getSchemaResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__getSchemaResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__getSchemaResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__getSchemaResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__getSchemaResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__getSchemaResponse(struct soap *soap, mindcall__getSchemaResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__getSchemaResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__getSchemaResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__getSchemaResponse(struct soap *soap, const char *tag, mindcall__getSchemaResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__getSchemaResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__getSchemaResponse, sizeof(mindcall__getSchemaResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__getSchemaResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__getSchemaResponse, sizeof(mindcall__getSchemaResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__getSchemaResponse *)soap_instantiate_mindcall__getSchemaResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__getSchemaResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__getSchemaResponse, sizeof(mindcall__getSchemaResponse *), 1), SOAP_mindcall__getSchemaResponse, sizeof(mindcall__getSchemaResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, mindcall__extractQBSFeaturesResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__extractQBSFeaturesResponse))
		soap_mark_PointerTomindcall__extractQBSFeaturesResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, mindcall__extractQBSFeaturesResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__extractQBSFeaturesResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__extractQBSFeaturesResponse(mindcall__extractQBSFeaturesResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, mindcall__extractQBSFeaturesResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__extractQBSFeaturesResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__extractQBSFeaturesResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__extractQBSFeaturesResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__extractQBSFeaturesResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, const char *tag, int id, mindcall__extractQBSFeaturesResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__extractQBSFeaturesResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__extractQBSFeaturesResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__extractQBSFeaturesResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__extractQBSFeaturesResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__extractQBSFeaturesResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, mindcall__extractQBSFeaturesResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__extractQBSFeaturesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__extractQBSFeaturesResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__extractQBSFeaturesResponse(struct soap *soap, const char *tag, mindcall__extractQBSFeaturesResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__extractQBSFeaturesResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__extractQBSFeaturesResponse, sizeof(mindcall__extractQBSFeaturesResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__extractQBSFeaturesResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__extractQBSFeaturesResponse, sizeof(mindcall__extractQBSFeaturesResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__extractQBSFeaturesResponse *)soap_instantiate_mindcall__extractQBSFeaturesResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__extractQBSFeaturesResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__extractQBSFeaturesResponse, sizeof(mindcall__extractQBSFeaturesResponse *), 1), SOAP_mindcall__extractQBSFeaturesResponse, sizeof(mindcall__extractQBSFeaturesResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__FeatureList(struct soap *soap, mindtype__FeatureList *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__FeatureList))
		soap_mark_PointerTomindtype__FeatureList(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__FeatureList(struct soap *soap, mindtype__FeatureList *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__FeatureList))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__FeatureList(mindtype__FeatureList **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__FeatureList(struct soap *soap, mindtype__FeatureList **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__FeatureList, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__FeatureList(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__FeatureList(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__FeatureList(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__FeatureList(struct soap *soap, const char *tag, int id, mindtype__FeatureList *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__FeatureList);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__FeatureList, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__FeatureList, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__FeatureList, &pp), type);
	}
}

SOAP_FMAC1 mindtype__FeatureList ** SOAP_FMAC2 soap_get_PointerTomindtype__FeatureList(struct soap *soap, mindtype__FeatureList **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__FeatureList(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__FeatureList ** SOAP_FMAC2 soap_in_PointerTomindtype__FeatureList(struct soap *soap, const char *tag, mindtype__FeatureList **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__FeatureList **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__FeatureList, sizeof(mindtype__FeatureList *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__FeatureList **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__FeatureList, sizeof(mindtype__FeatureList *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__FeatureList *)soap_instantiate_mindtype__FeatureList(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__FeatureList **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__FeatureList, sizeof(mindtype__FeatureList *), 1), SOAP_mindtype__FeatureList, sizeof(mindtype__FeatureList), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindcall__queryResponse(struct soap *soap, mindcall__queryResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindcall__queryResponse))
		soap_mark_PointerTomindcall__queryResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindcall__queryResponse(struct soap *soap, mindcall__queryResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindcall__queryResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindcall__queryResponse(mindcall__queryResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindcall__queryResponse(struct soap *soap, mindcall__queryResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindcall__queryResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindcall__queryResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindcall__queryResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindcall__queryResponse(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindcall__queryResponse(struct soap *soap, const char *tag, int id, mindcall__queryResponse *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindcall__queryResponse);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindcall__queryResponse, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__queryResponse, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindcall__queryResponse, &pp), type);
	}
}

SOAP_FMAC1 mindcall__queryResponse ** SOAP_FMAC2 soap_get_PointerTomindcall__queryResponse(struct soap *soap, mindcall__queryResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindcall__queryResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindcall__queryResponse ** SOAP_FMAC2 soap_in_PointerTomindcall__queryResponse(struct soap *soap, const char *tag, mindcall__queryResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindcall__queryResponse **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__queryResponse, sizeof(mindcall__queryResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindcall__queryResponse **)soap_id_enter(soap, "", a, SOAP_PointerTomindcall__queryResponse, sizeof(mindcall__queryResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindcall__queryResponse *)soap_instantiate_mindcall__queryResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindcall__queryResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindcall__queryResponse, sizeof(mindcall__queryResponse *), 1), SOAP_mindcall__queryResponse, sizeof(mindcall__queryResponse), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__PropResult(struct soap *soap, mindtype__PropResult *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__PropResult))
		soap_mark_PointerTomindtype__PropResult(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__PropResult(struct soap *soap, mindtype__PropResult *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__PropResult))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__PropResult(mindtype__PropResult **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__PropResult(struct soap *soap, mindtype__PropResult **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__PropResult, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__PropResult(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__PropResult(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__PropResult(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__PropResult(struct soap *soap, const char *tag, int id, mindtype__PropResult *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__PropResult);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__PropResult, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropResult, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropResult, &pp), type);
	}
}

SOAP_FMAC1 mindtype__PropResult ** SOAP_FMAC2 soap_get_PointerTomindtype__PropResult(struct soap *soap, mindtype__PropResult **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__PropResult(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__PropResult ** SOAP_FMAC2 soap_in_PointerTomindtype__PropResult(struct soap *soap, const char *tag, mindtype__PropResult **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__PropResult **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropResult, sizeof(mindtype__PropResult *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__PropResult **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__PropResult, sizeof(mindtype__PropResult *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__PropResult *)soap_instantiate_mindtype__PropResult(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__PropResult **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropResult, sizeof(mindtype__PropResult *), 1), SOAP_mindtype__PropResult, sizeof(mindtype__PropResult), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__PropDocument(struct soap *soap, mindtype__PropDocument *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__PropDocument))
		soap_mark_PointerTomindtype__PropDocument(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__PropDocument(struct soap *soap, mindtype__PropDocument *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__PropDocument))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__PropDocument(mindtype__PropDocument **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__PropDocument(struct soap *soap, mindtype__PropDocument **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__PropDocument, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__PropDocument(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__PropDocument(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__PropDocument(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__PropDocument(struct soap *soap, const char *tag, int id, mindtype__PropDocument *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__PropDocument);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__PropDocument, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropDocument, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropDocument, &pp), type);
	}
}

SOAP_FMAC1 mindtype__PropDocument ** SOAP_FMAC2 soap_get_PointerTomindtype__PropDocument(struct soap *soap, mindtype__PropDocument **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__PropDocument(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__PropDocument ** SOAP_FMAC2 soap_in_PointerTomindtype__PropDocument(struct soap *soap, const char *tag, mindtype__PropDocument **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__PropDocument **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropDocument, sizeof(mindtype__PropDocument *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__PropDocument **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__PropDocument, sizeof(mindtype__PropDocument *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__PropDocument *)soap_instantiate_mindtype__PropDocument(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__PropDocument **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropDocument, sizeof(mindtype__PropDocument *), 1), SOAP_mindtype__PropDocument, sizeof(mindtype__PropDocument), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__PropDocumentAttribute(struct soap *soap, mindtype__PropDocumentAttribute *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__PropDocumentAttribute))
		soap_mark_PointerTomindtype__PropDocumentAttribute(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__PropDocumentAttribute(struct soap *soap, mindtype__PropDocumentAttribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__PropDocumentAttribute))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__PropDocumentAttribute(mindtype__PropDocumentAttribute **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__PropDocumentAttribute(struct soap *soap, mindtype__PropDocumentAttribute **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__PropDocumentAttribute, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__PropDocumentAttribute(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__PropDocumentAttribute(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__PropDocumentAttribute(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__PropDocumentAttribute(struct soap *soap, const char *tag, int id, mindtype__PropDocumentAttribute *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__PropDocumentAttribute);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__PropDocumentAttribute, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropDocumentAttribute, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropDocumentAttribute, &pp), type);
	}
}

SOAP_FMAC1 mindtype__PropDocumentAttribute ** SOAP_FMAC2 soap_get_PointerTomindtype__PropDocumentAttribute(struct soap *soap, mindtype__PropDocumentAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__PropDocumentAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__PropDocumentAttribute ** SOAP_FMAC2 soap_in_PointerTomindtype__PropDocumentAttribute(struct soap *soap, const char *tag, mindtype__PropDocumentAttribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__PropDocumentAttribute **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropDocumentAttribute, sizeof(mindtype__PropDocumentAttribute *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__PropDocumentAttribute **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__PropDocumentAttribute, sizeof(mindtype__PropDocumentAttribute *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__PropDocumentAttribute *)soap_instantiate_mindtype__PropDocumentAttribute(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__PropDocumentAttribute **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropDocumentAttribute, sizeof(mindtype__PropDocumentAttribute *), 1), SOAP_mindtype__PropDocumentAttribute, sizeof(mindtype__PropDocumentAttribute), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__Query(struct soap *soap, mindtype__Query *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__Query))
		soap_mark_PointerTomindtype__Query(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__Query(struct soap *soap, mindtype__Query *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__Query))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__Query(mindtype__Query **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__Query(struct soap *soap, mindtype__Query **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__Query, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__Query(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__Query(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__Query(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__Query(struct soap *soap, const char *tag, int id, mindtype__Query *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__Query);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__Query, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__Query, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__Query, &pp), type);
	}
}

SOAP_FMAC1 mindtype__Query ** SOAP_FMAC2 soap_get_PointerTomindtype__Query(struct soap *soap, mindtype__Query **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__Query(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__Query ** SOAP_FMAC2 soap_in_PointerTomindtype__Query(struct soap *soap, const char *tag, mindtype__Query **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__Query **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__Query, sizeof(mindtype__Query *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__Query **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__Query, sizeof(mindtype__Query *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__Query *)soap_instantiate_mindtype__Query(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__Query **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__Query, sizeof(mindtype__Query *), 1), SOAP_mindtype__Query, sizeof(mindtype__Query), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__Schema(struct soap *soap, mindtype__Schema *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__Schema))
		soap_mark_PointerTomindtype__Schema(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__Schema(struct soap *soap, mindtype__Schema *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__Schema))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__Schema(mindtype__Schema **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__Schema(struct soap *soap, mindtype__Schema **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__Schema, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__Schema(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__Schema(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__Schema(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__Schema(struct soap *soap, const char *tag, int id, mindtype__Schema *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__Schema);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__Schema, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__Schema, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__Schema, &pp), type);
	}
}

SOAP_FMAC1 mindtype__Schema ** SOAP_FMAC2 soap_get_PointerTomindtype__Schema(struct soap *soap, mindtype__Schema **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__Schema(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__Schema ** SOAP_FMAC2 soap_in_PointerTomindtype__Schema(struct soap *soap, const char *tag, mindtype__Schema **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__Schema **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__Schema, sizeof(mindtype__Schema *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__Schema **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__Schema, sizeof(mindtype__Schema *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__Schema *)soap_instantiate_mindtype__Schema(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__Schema **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__Schema, sizeof(mindtype__Schema *), 1), SOAP_mindtype__Schema, sizeof(mindtype__Schema), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__PropQueryCondition(struct soap *soap, mindtype__PropQueryCondition *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__PropQueryCondition))
		soap_mark_PointerTomindtype__PropQueryCondition(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__PropQueryCondition(struct soap *soap, mindtype__PropQueryCondition *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__PropQueryCondition))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__PropQueryCondition(mindtype__PropQueryCondition **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__PropQueryCondition(struct soap *soap, mindtype__PropQueryCondition **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__PropQueryCondition, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__PropQueryCondition(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__PropQueryCondition(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__PropQueryCondition(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__PropQueryCondition(struct soap *soap, const char *tag, int id, mindtype__PropQueryCondition *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__PropQueryCondition);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__PropQueryCondition, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropQueryCondition, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__PropQueryCondition, &pp), type);
	}
}

SOAP_FMAC1 mindtype__PropQueryCondition ** SOAP_FMAC2 soap_get_PointerTomindtype__PropQueryCondition(struct soap *soap, mindtype__PropQueryCondition **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__PropQueryCondition(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__PropQueryCondition ** SOAP_FMAC2 soap_in_PointerTomindtype__PropQueryCondition(struct soap *soap, const char *tag, mindtype__PropQueryCondition **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__PropQueryCondition **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropQueryCondition, sizeof(mindtype__PropQueryCondition *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__PropQueryCondition **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__PropQueryCondition, sizeof(mindtype__PropQueryCondition *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__PropQueryCondition *)soap_instantiate_mindtype__PropQueryCondition(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__PropQueryCondition **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__PropQueryCondition, sizeof(mindtype__PropQueryCondition *), 1), SOAP_mindtype__PropQueryCondition, sizeof(mindtype__PropQueryCondition), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToSchemaAttributeArray(struct soap *soap, SchemaAttributeArray *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerToSchemaAttributeArray))
		soap_mark_PointerToSchemaAttributeArray(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToSchemaAttributeArray(struct soap *soap, SchemaAttributeArray *const*a)
{
	if (!soap_reference(soap, *a, SOAP_SchemaAttributeArray))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToSchemaAttributeArray(SchemaAttributeArray **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerToSchemaAttributeArray(struct soap *soap, SchemaAttributeArray **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerToSchemaAttributeArray, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToSchemaAttributeArray(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToSchemaAttributeArray(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToSchemaAttributeArray(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerToSchemaAttributeArray(struct soap *soap, const char *tag, int id, SchemaAttributeArray *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerToSchemaAttributeArray);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_SchemaAttributeArray, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_SchemaAttributeArray, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_SchemaAttributeArray, &pp), type);
	}
}

SOAP_FMAC1 SchemaAttributeArray ** SOAP_FMAC2 soap_get_PointerToSchemaAttributeArray(struct soap *soap, SchemaAttributeArray **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSchemaAttributeArray(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 SchemaAttributeArray ** SOAP_FMAC2 soap_in_PointerToSchemaAttributeArray(struct soap *soap, const char *tag, SchemaAttributeArray **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (SchemaAttributeArray **)soap_id_enter(soap, soap->id, a, SOAP_PointerToSchemaAttributeArray, sizeof(SchemaAttributeArray *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (SchemaAttributeArray **)soap_id_enter(soap, "", a, SOAP_PointerToSchemaAttributeArray, sizeof(SchemaAttributeArray *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (SchemaAttributeArray *)soap_instantiate_SchemaAttributeArray(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (SchemaAttributeArray **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerToSchemaAttributeArray, sizeof(SchemaAttributeArray *), 1), SOAP_SchemaAttributeArray, sizeof(SchemaAttributeArray), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute **const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerToPointerTomindtype__SchemaAttribute))
		soap_mark_PointerToPointerTomindtype__SchemaAttribute(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute **const*a)
{
	if (!soap_reference(soap, *a, SOAP_PointerTomindtype__SchemaAttribute))
		soap_mark_PointerTomindtype__SchemaAttribute(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToPointerTomindtype__SchemaAttribute(mindtype__SchemaAttribute ***a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute ***a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerToPointerTomindtype__SchemaAttribute, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToPointerTomindtype__SchemaAttribute(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToPointerTomindtype__SchemaAttribute(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToPointerTomindtype__SchemaAttribute(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, const char *tag, int id, mindtype__SchemaAttribute **const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerToPointerTomindtype__SchemaAttribute);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_PointerTomindtype__SchemaAttribute, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_PointerTomindtype__SchemaAttribute(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_PointerTomindtype__SchemaAttribute(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_PointerTomindtype__SchemaAttribute(soap, tag, soap_pointer_enter(soap, *a, SOAP_PointerTomindtype__SchemaAttribute, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_PointerTomindtype__SchemaAttribute(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_PointerTomindtype__SchemaAttribute(soap, tag, i, *a, type);
	                     }
	              else    soap_out_PointerTomindtype__SchemaAttribute(soap, tag, soap_pointer_enter(soap, *a, SOAP_PointerTomindtype__SchemaAttribute, &pp),*a, type);
	}
}

SOAP_FMAC1 mindtype__SchemaAttribute *** SOAP_FMAC2 soap_get_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTomindtype__SchemaAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__SchemaAttribute *** SOAP_FMAC2 soap_in_PointerToPointerTomindtype__SchemaAttribute(struct soap *soap, const char *tag, mindtype__SchemaAttribute ***a, const char *type)
{
	mindtype__SchemaAttribute **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__SchemaAttribute ***)soap_id_enter(soap, soap->id, a, SOAP_PointerToPointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute **), 2);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_PointerTomindtype__SchemaAttribute(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_PointerTomindtype__SchemaAttribute(soap, tag, NULL, type)))
		{	a = (mindtype__SchemaAttribute ***)soap_id_enter(soap, "", NULL, SOAP_PointerToPointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute **), 0);
			if (!a)
				return NULL;
			*a = p;
		}
	}
	else
	{	a = (mindtype__SchemaAttribute ***)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerToPointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute **), 2), SOAP_PointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute *), 1);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute *const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerTomindtype__SchemaAttribute))
		soap_mark_PointerTomindtype__SchemaAttribute(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute *const*a)
{
	if (!soap_reference(soap, *a, SOAP_mindtype__SchemaAttribute))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTomindtype__SchemaAttribute(mindtype__SchemaAttribute **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerTomindtype__SchemaAttribute, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTomindtype__SchemaAttribute(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTomindtype__SchemaAttribute(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTomindtype__SchemaAttribute(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerTomindtype__SchemaAttribute(struct soap *soap, const char *tag, int id, mindtype__SchemaAttribute *const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerTomindtype__SchemaAttribute);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_mindtype__SchemaAttribute, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           (*a)->soap_out(soap, tag, 0, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       (*a)->soap_out(soap, tag, i, type);
	                   }
	                   else   (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__SchemaAttribute, &pp), type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if (soap_is_single(soap, pp))
	                             (*a)->soap_out(soap, tag, 0, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          (*a)->soap_out(soap, tag, i, type);
	                     }
	              else    (*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_mindtype__SchemaAttribute, &pp), type);
	}
}

SOAP_FMAC1 mindtype__SchemaAttribute ** SOAP_FMAC2 soap_get_PointerTomindtype__SchemaAttribute(struct soap *soap, mindtype__SchemaAttribute **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTomindtype__SchemaAttribute(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 mindtype__SchemaAttribute ** SOAP_FMAC2 soap_in_PointerTomindtype__SchemaAttribute(struct soap *soap, const char *tag, mindtype__SchemaAttribute **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (mindtype__SchemaAttribute **)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		a = (mindtype__SchemaAttribute **)soap_id_enter(soap, "", a, SOAP_PointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (mindtype__SchemaAttribute *)soap_instantiate_mindtype__SchemaAttribute(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default();
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (mindtype__SchemaAttribute **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerTomindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute *), 1), SOAP_mindtype__SchemaAttribute, sizeof(mindtype__SchemaAttribute), 0);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, a, SOAP_PointerToxsd__string))
		soap_mark_PointerToxsd__string(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_xsd__string))
		soap_mark_xsd__string(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToxsd__string(char ***a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_PointerToxsd__string(struct soap *soap, char ***a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_PointerToxsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToxsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToxsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToxsd__string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	int i;
	struct soap_plist *pp;
	id = soap_embedded_id(soap, id, a, SOAP_PointerToxsd__string);
	if(*a == NULL)
	         soap_element_null(soap, tag, id, type);
	else
	{
	         i = soap_pointer_lookup(soap, *a, SOAP_xsd__string, &pp);
	         if (id > 0)
			{
		        if (i)
		              if (soap_is_embedded(soap, pp))
				   soap_element_ref(soap, tag, id, i);
	                   else if (soap_is_single(soap, pp))
	 		           soap_out_xsd__string(soap, tag, 0, *a, type);
	                   else
	{
				   soap_set_embedded(soap, pp);
	                       soap_out_xsd__string(soap, tag, i, *a, type);
	                   }
	                   else   soap_out_xsd__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_xsd__string, &pp), *a, type);
	              }
	              else if (i)
	                     if (soap_is_embedded(soap, pp))
	                          soap_element_ref(soap, tag, 0, i);
	                     else if(soap_is_single(soap, pp))
	                             soap_out_xsd__string(soap, tag, 0, *a, type);
	                      else
	{
	                          soap_set_embedded(soap, pp);
	                          soap_out_xsd__string(soap, tag, i, *a, type);
	                     }
	              else    soap_out_xsd__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_xsd__string, &pp),*a, type);
	}
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (char ***)soap_id_enter(soap, soap->id, a, SOAP_PointerToxsd__string, sizeof(char **), 2);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (soap->body && !*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_xsd__string(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_xsd__string(soap, tag, NULL, type)))
		{	a = (char ***)soap_id_enter(soap, "", NULL, SOAP_PointerToxsd__string, sizeof(char **), 0);
			if (!a)
				return NULL;
			*a = p;
		}
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_PointerToxsd__string, sizeof(char **), 2), SOAP_xsd__string, sizeof(char *), 1);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(char **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_xsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	soap_outstring(soap, tag, id, a, type, SOAP_xsd__string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(char **a)
{
	*a = NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	soap_putindependent(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	soap_outstring(soap, tag, id, a, type, SOAP_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_string);
}

/* end of soapC.cpp */
