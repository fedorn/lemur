/*==========================================================================
 * Copyright (c) 2002 University of Massachusetts.  All Rights Reserved.
 *
 * Use of the Lemur Toolkit for Language Modeling and Information Retrieval
 * is subject to the terms of the software license set forth in the LICENSE
 * file included with this software, and also available at
 * http://www.lemurproject.org/license.html
 *
 *==========================================================================
*/

/*! \page RetQueryClarity Query Clarity with Retrieval

<p> This application computes clarity scores for an expanded query model
based on pseudo-feedback documents. Performs the retrieval of those
documents using the relevant SimpleKLRetMethod parameters.  Clarity
scores for each entire query, and each individual term within each query
are written to the file specified by the parameter "expandedQuery".

<p>
Parameters:
<ol>

<li> <tt>index</tt>: The complete name of the index table-of-content
file for the database index.

<li> <tt>smoothSupportFile</tt>: The name of the smoothing support file
(e.g., one generated by GenerateSmoothSupport).

<li> <tt>textQuery</tt>: the original query text stream 

<li> <tt>expandedQuery</tt>: the file to store the query clarity scores.

<li> <tt>feedbackDocCount</tt>: the number of docs to use for 
pseudo-feedback. If not specified or 0, the value defaults to 500.

<li> <tt>queryUpdateMethod</tt>: feedback method, one of:
<ul>
<li><tt>mixture</tt> or <tt>mix</tt> or 0 for mixture.
<li><tt>divmin</tt> or <tt>div</tt> or 1 for div min
<li><tt>markovchain</tt> or <tt>mc</tt> or 2 for markov chain
<li><tt>relevancemodel1</tt> or <tt>rm1</tt> or 3 for relevance model 1.
<li><tt>relevancemodel2</tt> or <tt>rm2</tt> or 4 for relevance model 2.
</ul>


<li>  Method-specific feedback parameters:
<p>
For all interpolation-based approaches (i.e., the new query model is an 
interpolation of the original model with a (feedback) model computed based 
on the feedback documents), the following four parameters apply:
<ol>
<li> <tt>feedbackCoefficient</tt>: the coefficient of the feedback model 
for interpolation. The value is in [0,1], with 0 meaning using only the 
original model (thus no updating/feedback) and 1 meaning using only the 
feedback model (thus ignoring the original model).

<li> <tt>feedbackTermCount</tt>: Truncate the feedback model to no more 
than a given number of words/terms.

<li> <tt>feedbackProbThresh</tt>: Truncate the feedback model to include 
only words with a probability higher than this threshold. 
Default value: 0.001.

<li> <tt>feedbackProbSumThresh</tt>: Truncate the feedback model until 
the sum of the probability of the included words reaches this threshold. 
Default value: 1.
<p>
</ol>
</ol>
Parameters <tt>feedbackTermCount</tt>, <tt>feedbackProbThresh</tt>, and 
<tt>feedbackProbSumThresh</tt> work conjunctively to control the truncation, 
i.e., the truncated model must satisfy all the three constraints. 
<p>
All the three feedback methods also recognize the parameter 
<tt>feedbackMixtureNoise</tt> (default value :0.5), but with 
<em>different</em> interpretations.
<ul>
<li> For the collection mixture model method, <tt>feedbackMixtureNoise</tt> 
is the collection model selection probability in the mixture model. That is,
with this probability, a word is picked according to the collection language
model, when a feedback document is "generated".
<li> For the divergence minimization method, <tt>feedbackMixtureNoise</tt> 
means the weight of the divergence from the collection language model. 
(The higher it is, the farther the estimated model is from the collection 
model.)
<li> For the Markov chain method, <tt>feedbackMixtureNoise</tt> is the 
probability of <em>not</em> stopping, i.e., <tt>1- alpha</tt>, where 
alpha is the stopping probability while walking through the chain. 
</ul>
<p>
In addition, the collection mixture model also recognizes the parameter 
<tt>emIterations</tt>, which is the maximum number of iterations the EM 
algorithm will run. Default: 50. (The EM algorithm can terminate earlier 
if the log-likelihood converges quickly, where convergence is measured 
by some hard-coded criterion. See the source code in 
<tt>SimpleKLRetMethod.cpp</tt> for details. )
 */
/*
  author: fff
 */

#include "common_headers.hpp" 
#include "IndexManager.hpp"
#include "BasicDocStream.hpp"
#include "RetParamManager.hpp"
#include "ResultFile.hpp"
using namespace lemur::api;


namespace LocalParameter {

  std::string expandedQuery;
  std::string initQuery;
  std::string feedbackDocuments;
  void get() {
    expandedQuery = ParamGetString("expandedQuery");
  }
};

void GetAppParam()
{
  LocalParameter::get();
  RetrievalParameter::get();  
  SimpleKLParameter::get();
  if (RetrievalParameter::fbDocCount == 0) {
    // user didn't supply a parameter, no docs makes no sense.
    RetrievalParameter::fbDocCount = 500;
  }
  SimpleKLParameter::qryPrm.adjScoreMethod = 
    SimpleKLParameter::QUERYLIKELIHOOD;
}

void QueryClarity(QueryRep *qr, const string& qid, IndexedRealVector *res, 
                  RetrievalMethod *model, ofstream &os)

{
  bool ignoreWeights = false;
  cout << "query : "<< qid << endl;
  lemur::retrieval::SimpleKLQueryModel *qm = (lemur::retrieval::SimpleKLQueryModel *) qr;
  model->scoreCollection(*qr, *res);
  res->LogToPosterior();
  res->Sort();  
  PseudoFBDocs *topDoc = new PseudoFBDocs(*res, 
                                          RetrievalParameter::fbDocCount,
                                          ignoreWeights);
  model->updateQuery(*qr, *topDoc);
  delete topDoc;
  os << qid;
  qm->clarity(os);
}

int AppMain(int argc, char *argv[]) {

  Index  *ind;

  try {
    ind = IndexManager::openIndex(RetrievalParameter::databaseIndex);
  } 
  catch (Exception &ex) {
    ex.writeMessage();
    throw Exception("QueryClarity", 
                    "Can't open index, check parameter index");
  }

  lemur::retrieval::ArrayAccumulator accumulator(ind->docCount());
  IndexedRealVector res(ind->docCount());
  ofstream os(LocalParameter::expandedQuery.c_str());

  lemur::retrieval::SimpleKLRetMethod *model;
  model =  new lemur::retrieval::SimpleKLRetMethod(*ind, SimpleKLParameter::smoothSupportFile, 
                                 accumulator);
  model->setDocSmoothParam(SimpleKLParameter::docPrm);
  model->setQueryModelParam(SimpleKLParameter::qryPrm);
  DocStream *qryStream;
  try {
    qryStream = new lemur::parse::BasicDocStream(RetrievalParameter::textQuerySet);
  } catch (Exception &ex) {
    ex.writeMessage(cerr);
    throw Exception("QueryClarity", "Can't open query file");
  }
  qryStream->startDocIteration();
  TextQuery *q;
  while (qryStream->hasMore()) {
    Document *d = qryStream->nextDoc();
    q = new TextQuery(*d);
    QueryRep *qr = model->computeQueryRep(*q);
    res.clear();
    QueryClarity(qr, q->id(), &res, model, os);     
    delete qr;
    delete q;
  }
  os.close();
  delete model;
  delete qryStream;
  delete ind;
  return 0;
}


