/*==========================================================================
 * Copyright (c) 2001 Carnegie Mellon University.  All Rights Reserved.
 *
 * Use of the Lemur Toolkit for Language Modeling and Information Retrieval
 * is subject to the terms of the software license set forth in the LICENSE
 * file included with this software, and also available at
 * http://www.lemurproject.org/license.html
 *
 *==========================================================================
*/

/*! \page QueryModelEval  Query Model Evaluation Application 

<p> This application loads an expanded query model (e.g., one computed
by GenerateQueryModel), and evaluates it with the KL-divergence
retrieval model.

<p>Parameters:

<ol>

<li> <tt>index</tt>: The complete name of the index table-of-content
file for the database index.

<li> <tt>smoothSupportFile</tt>: The name of the smoothing support file
(e.g., one generated by GenerateSmoothSupport).

<li> <tt>queryModel</tt>: the file of the query model to be evaluted 

<li> <tt>resultFile</tt>: the result file 

<li> <tt>resultFormat</tt>: whether the result format should be of the
 TREC format (i.e., six-column) or just a simple three-column format
 <tt>&lt;queryID, docID, score&gt;</tt>. Boolean value, false for non-TREC
 format, and true for TREC format. Default: true (i.e., TREC format)

<li> <tt>resultCount</tt>: the number of documents to return as result
for each query

<p> The following are document model smoothing parameters:

<li> <tt>smoothMethod</tt>: One of the four: 
<ul>
<li><tt>jelinikmercer</tt> or <tt>jm</tt> or 0 for Jelinek-Mercer
<li><tt>dirichletprior</tt> or <tt>dir</tt> or 1 for Dirichlet prior 
<li><tt>absolutediscount</tt> or <tt>ad</tt> or 2 for Absolute
discounting
<li><tt>twostage</tt> or <tt>2s</tt> or 3 for two stage.
</ul>

<li> <tt>smoothStrategy</tt>: Either <tt>interpolate</tt> or 0 for
interpolate or <tt>backoff</tt> or 1 for backoff.

<li> <tt>adjustedScoreMethod</tt>: Which type of score to output, one of:
<ul>
<li> "querylikelihood" or "ql" for query likelihood.
<li> "crossentropy" or "ce" for cross entropy.
<li> "negativekld" or "-d" for negative KL divergence.
</ul>

<li> <tt>JelinekMercerLambda</tt>: The collection model weight in the JM
interpolation method. Default: 0.5

<li> <tt>DirichletPrior</tt>: The prior parameter in the Dirichlet prior
smoothing method. Default: 1000

<li> <tt>discountDelta</tt>: The delta (discounting constant) in the
absolute discounting method. Default 0.7.
</ol>
 */

#include "common_headers.hpp" 
#include "IndexManager.hpp"
#include "BasicDocStream.hpp"
#include "RetParamManager.hpp"
#include "ResultFile.hpp"

using namespace lemur::api;

namespace LocalParameter {
  std::string queryModel;

  void get() {
    queryModel = ParamGetString("queryModel","");
  }
};

void GetAppParam()
{
  LocalParameter::get();
  RetrievalParameter::get();
  SimpleKLParameter::get();
}



/// A query model estimation program
int AppMain(int argc, char *argv[]) {
  
  Index  *ind;

  try {
    ind =  IndexManager::openIndex(RetrievalParameter::databaseIndex);
  } 
  catch (Exception &ex) {
    ex.writeMessage();
    throw Exception("QueryModelEval", 
                    "Can't open index, check parameter index");
  }

  ifstream *workSetStr;
  ResultFile *docPool;
  if (RetrievalParameter::useWorkingSet) {
    workSetStr = new ifstream(RetrievalParameter::workSetFile.c_str(), ios::in | ios::binary);
    if (workSetStr->fail()) {
      throw Exception("RetEval", "can't open working set file");
    }
    docPool = new ResultFile(false); // working set is always simple format
    docPool->openForRead(*workSetStr, *ind);
  }

  ifstream qmodel(LocalParameter::queryModel.c_str(), ios::in | ios::binary);

  lemur::retrieval::ArrayAccumulator accumulator(ind->docCount());

  if (qmodel.fail()) {
    throw Exception("QueryModelEval", 
                    "can't open the query model file, check the value for parameter queryModel");
  }
  
  ofstream result(RetrievalParameter::resultFile.c_str());

  ResultFile resFile(RetrievalParameter::TRECresultFileFormat);

  resFile.openForWrite(result, *ind);

  lemur::retrieval::SimpleKLRetMethod model(*ind, SimpleKLParameter::smoothSupportFile, 
                          accumulator);
  
  model.setDocSmoothParam(SimpleKLParameter::docPrm);
  model.setQueryModelParam(SimpleKLParameter::qryPrm);

  IndexedRealVector res;
  char qid[300];

  lemur::retrieval::SimpleKLQueryModel *q;
  IndexedRealVector workSetRes;

  while (qmodel >> qid) {
    cout << "Query "<< qid << endl;
    q = new lemur::retrieval::SimpleKLQueryModel(*ind);
    q->load(qmodel);
    PseudoFBDocs *workSet;
    if (RetrievalParameter::useWorkingSet) {
      docPool->getResult(qid, workSetRes);
      workSet = new PseudoFBDocs(workSetRes, -1); // -1 means using all docs
      model.scoreDocSet(*q,*workSet,res);
      delete(workSet);
    } else {
      model.scoreCollection(*q, res);
    }

    res.Sort();
    resFile.writeResults(qid, &res, RetrievalParameter::resultCount);
    delete q;
  }
  if (RetrievalParameter::useWorkingSet) {
    delete docPool;
    delete workSetStr;
  }
  result.close();
  delete ind;
  return 0;
}
