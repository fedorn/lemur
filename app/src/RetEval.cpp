/*==========================================================================
 * Copyright (c) 2001 Carnegie Mellon University.  All Rights Reserved.
 *
 * Use of the Lemur Toolkit for Language Modeling and Information Retrieval
 * is subject to the terms of the software license set forth in the LICENSE
 * file included with this software, and also available at
 * http://www.cs.cmu.edu/~lemur/license.html
 *
 *==========================================================================
*/




/// A General Retrieval Evaluation Program



/*! \page RetrievalEvaluation Retrieval Evaluation Application

This application (RetEval.cpp) runs retrieval experiments (with/without feedback) to
evaluate different retrieval models as well as different parameter
settings for those models. 

It currently supports three different models:

1) The popular TFIDF retrieval model

2) The Okapi BM25 retrieval function

3) The KL-divergence language model based retrieval method

The parameter to select the model is "retModel" (with value 0 for
TFIDF, 1 for Okapi, and 2 for KL)

Other common parameters (for all retrieval methods)  are:

1) "index": The complete name of the index table-of-content file for the database index.

2) "textQuerySet": the query text stream 

3) "resultFile": the result file

4) "resultCount": the number of documents to return as result for each query

5) "feedbackDocCount": the number of docs to use for pseudo-feedback (0 means no-feedback)

6) "feedbackTermCount": the number of terms to add to a query when doing feedback. Note that
    in the KL-div. approach, the actual number of terms is also affected by two other parameters.(See below.)

Other model-specific parameters are:

For TFIDF:

1) "feedbackPosCoeff": the coefficient for positive terms in (positive) Rocchio feedback. We only implemented the "positive" part and non-relevant documents are ignored.

2) "doc.tfMethod": document term TF weighting method: 0 for RawTF, 1 for log-TF, and 2 for BM25TF

3) "doc.bm25K1": BM25 k1 for doc term TF

4) "doc.bm25B" : BM25 b for doc term TF

5) "query.tfMethod": query term TF weighting method: 0 for RawTF, 1 for log-TF, and 2 for BM25TF

6) "query.bm25K1": BM25 k1 for query term TF. bm25B is set to zero for query terms

For Okapi:

1) "BM25K1" : BM25 K1

2) "BM25B" : BM25 B

4) "BM25K3": BM25 K3 

5) "BM25QTF": The TF for expanded terms in feedback (the original paper
about the Okapi system is not clear about how this is set, so
it's implemented as a parameter.)

For KL-divergence:

Document model smoothing parameters:

1) "smoothSupportFile": The name of the smoothing support file (e.g., one generated by GenerateSmoothSupport).

2) "smoothMethod": One of the three: Jelinek-Mercer (0), Dirichlet prior (1), and Absolute discounting (2)

3) "smoothStrategy": Either "interpolate" (0) or "backoff" (1)

4) "JelinekMercerLambda": The collection model weight in the JM interpolation method. Default: 0.5

5) "DirichletPrior": The prior parameter in the Dirichlet prior smoothing method. Default: 1000

6) "discountDelta": The delta (discounting constant) in the absolute discounting method. Default 0.7.

Query model updating method (i.e., pseudo feedback):

7) "queryUpdateMethod": feedback method (0, 1, 2 for mixture model, divergence minimization, and Markov chain respectively, but currently only mixture model is implemented).

8) Method-specific parameters:

For all interpolation-based approaches (i.e., the new query model is an interpolation of the original
model with a (feedback) model computed based on the feedback documents), the following four
parameters apply:

8.1) "feedbackCoefficient": the coefficient of the feedback model for interpolation. The value is in [0,1], with 0 meaning using only the original model (thus no updating/feedback) and 1 meaning using only the feedback model (thus ignoring the original model).

8.2) "feedbackTermCount": Truncate the feedback model to no more than a given number of words/terms.

8.3) "feedbackProbThresh": Truncate the feedback model to include only words with a probability higher than this threshold. Default value: 0.001.

8.4) "feedbackProbSumThresh": Truncate the feedback model until the sum of the probability of the included words reaches this threshold. Default value: 1.

Parameters 8.2), 8.3) and 8.4) work conjunctively to control the truncation, i.e., the truncated model must satisfy all the three constraints. 

The collection mixture method also recognizes the following two additional parameters:

8.5) "feedbackMixtureNoise": This is the collection model selection probability in the mixture model. That is, with this probability, a word is picked according to the collection language model, when a feedback document is "generated". Default: 0.5.

8.6) "emIterations": The maximum number of iterations the EM algorithm will run. Default: 50. The algorithm will also stop if the log-likelihood increase is no more than 0.5. 

 */



#include "Param.hpp"
#include "IndexManager.hpp"
#include "BasicDocStream.hpp"
#include <iostream.h>
#include "TFIDFRetMethod.hpp"
#include "SimpleKLRetMethod.hpp"
#include "OkapiRetMethod.hpp"
#include "ParamManager.hpp"
#include "ResultFile.hpp"

namespace LocalParameter {
  enum RetModel {TFIDF=0, OKAPI=1, KL=2};
  /// retrieval model 
  static enum RetModel mod;
  static bool TRECResultFormat;
  bool useWorkingSet;
  String workSetFile;
  void get() {
    mod = (RetModel) ParamGetInt("retModel",KL); // default is KL divergence model
    TRECResultFormat = ParamGetInt("resultFormat",1); // default is TREC format
    useWorkingSet = ParamGetInt("useWorkingSet", 0); //default is to score the whole collection; otherwise, score a subset
    workSetFile = ParamGetString("workingSetFile",""); // working set file name
  }
};

void GetAppParam()
{
  RetrievalParameter::get();
  LocalParameter::get();
}



/// A retrieval evaluation program
int AppMain(int argc, char *argv[]) {
  
  Index  *ind = IndexManager::openIndex(RetrievalParameter::databaseIndex);
  DocStream *qryStream = new BasicDocStream(RetrievalParameter::textQuerySet);

  ofstream result(RetrievalParameter::resultFile);
  ResultFile resFile(LocalParameter::TRECResultFormat);
  resFile.openForWrite(result, *ind);

  ifstream workSetStr(LocalParameter::workSetFile);
  ResultFile docPool(false); // working set is always simple format
  docPool.openForRead(workSetStr, *ind);

  ArrayAccumulator accumulator(ind->docCount());

  IndexedRealVector results(ind->docCount());

  RetrievalMethod *model;

  // construct retrieval model

  switch (LocalParameter::mod) {
  case LocalParameter::TFIDF: 
    model = new TFIDFRetMethod(*ind, accumulator);
    TFIDFParameter::get();
    ((TFIDFRetMethod *)model)->setDocTFParam(TFIDFParameter::docTFPrm);
    ((TFIDFRetMethod *)model)->setQueryTFParam(TFIDFParameter::qryTFPrm);
    ((TFIDFRetMethod *)model)->setFeedbackParam(TFIDFParameter::fbPrm);
    break;
  case LocalParameter::OKAPI:
    model = new OkapiRetMethod(*ind, accumulator);
    OkapiParameter::get();
    ((OkapiRetMethod *)model)->setTFParam(OkapiParameter::tfPrm);
    ((OkapiRetMethod *)model)->setFeedbackParam(OkapiParameter::fbPrm);
    break;
  case LocalParameter::KL:
    SimpleKLParameter::get();
    model = new SimpleKLRetMethod(*ind, SimpleKLParameter::smoothSupportFile, accumulator);
    ((SimpleKLRetMethod *)model)->setDocSmoothParam(SimpleKLParameter::docPrm);
    ((SimpleKLRetMethod *)model)->setQueryModelParam(SimpleKLParameter::qryPrm);
    break;
  default:
    throw Exception("RetrievalExp", "unknown retModel parameter");
    break;
    
  }

  qryStream->startDocIteration();
  TextQuery *q;
  
  IndexedRealVector workSetRes;
  
  while (qryStream->hasMore()) {
    Document *d = qryStream->nextDoc();
    q = new TextQuery(*d);
    cout << "query : "<< q->id() << endl;
    QueryRep * qr = model->computeQueryRep(*q);
    PseudoFBDocs *workSet;

    if (LocalParameter::useWorkingSet) {
      docPool.getResult(q->id(), workSetRes);
      workSet = new PseudoFBDocs(workSetRes, -1); // -1 means using all docs
      model->scoreDocSet(*qr,*workSet,results);
    } else {
      model->scoreCollection(*qr, results);
    }

    results.Sort();
    if (RetrievalParameter::fbDocCount>0) {
      PseudoFBDocs *topDoc = new PseudoFBDocs(results, RetrievalParameter::fbDocCount);
      model->updateQuery(*qr, *topDoc);
     
      if (LocalParameter::useWorkingSet) {
	model->scoreDocSet(*qr,*workSet,results);
	delete workSet;
      } else {
	model->scoreCollection(*qr, results);
      } 
      results.Sort();
      delete topDoc;
    }
    resFile.writeResults(q->id(), &results, RetrievalParameter::resultCount);
    delete qr;
    delete q;
  }

  result.close();
  delete qryStream;
  delete ind;
  return 0;

}


